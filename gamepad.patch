diff --git a/dlls/dinput/Makefile.in b/dlls/dinput/Makefile.in
index d4bb1bc..112ce44 100755
--- a/dlls/dinput/Makefile.in
+++ b/dlls/dinput/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = dinput.dll
 IMPORTLIB = dinput
-IMPORTS   = dinput dxguid uuid comctl32 ole32 user32 advapi32 hid setupapi
+IMPORTS   = dinput dxguid uuid comctl32 ole32 user32 advapi32 hid setupapi ws2_32
 EXTRADEFS = -DDIRECTINPUT_VERSION=0x0700
 
 SOURCES = \
@@ -15,4 +15,5 @@ SOURCES = \
 	joystick_hid.c \
 	keyboard.c \
 	mouse.c \
-	version.rc
+	version.rc \
+    gamepad.c
diff --git a/dlls/dinput/dinput.c b/dlls/dinput/dinput.c
index 76c60b0..1d2c4b6 100755
--- a/dlls/dinput/dinput.c
+++ b/dlls/dinput/dinput.c
@@ -282,6 +282,7 @@ static HRESULT WINAPI dinput7_CreateDeviceEx( IDirectInput7W *iface, const GUID
 
     if (IsEqualGUID( &GUID_SysKeyboard, guid )) hr = keyboard_create_device( impl, guid, &device );
     else if (IsEqualGUID( &GUID_SysMouse, guid )) hr = mouse_create_device( impl, guid, &device );
+    else if (IsEqualGUID( &GUID_Joystick, guid )) hr = gamepad_create_device( impl, guid, &device );
     else hr = hid_joystick_create_device( impl, guid, &device );
 
     if (FAILED(hr)) return hr;
@@ -378,6 +379,10 @@ static HRESULT WINAPI dinput8_EnumDevices( IDirectInput8W *iface, DWORD type, LP
             if (hr == DI_OK && try_enum_device( device_type, callback, &instance, context, flags ) == DIENUM_STOP)
                 return DI_OK;
         } while (SUCCEEDED(hr));
+        
+        hr = gamepad_enum_device( type, flags, &instance, impl->dwVersion );
+        if (hr == DI_OK && try_enum_device( device_type, callback, &instance, context, flags ) == DIENUM_STOP)
+            return DI_OK;        
     }
 
     return DI_OK;
diff --git a/dlls/dinput/dinput_private.h b/dlls/dinput/dinput_private.h
index 0609b81..c1d5b07 100755
--- a/dlls/dinput/dinput_private.h
+++ b/dlls/dinput/dinput_private.h
@@ -56,6 +56,8 @@ extern HRESULT keyboard_enum_device( DWORD type, DWORD flags, DIDEVICEINSTANCEW
 extern HRESULT keyboard_create_device( struct dinput *dinput, const GUID *guid, IDirectInputDevice8W **out );
 extern HRESULT hid_joystick_enum_device( DWORD type, DWORD flags, DIDEVICEINSTANCEW *instance, DWORD version, int index );
 extern HRESULT hid_joystick_create_device( struct dinput *dinput, const GUID *guid, IDirectInputDevice8W **out );
+extern HRESULT gamepad_enum_device( DWORD type, DWORD flags, DIDEVICEINSTANCEW *instance, DWORD version );
+extern HRESULT gamepad_create_device( struct dinput *dinput, const GUID *guid, IDirectInputDevice8W **out );
 
 struct DevicePlayer {
     GUID instance_guid;
diff --git a/dlls/dinput/gamepad.c b/dlls/dinput/gamepad.c
new file mode 100755
index 0000000..bedb94b
--- /dev/null
+++ b/dlls/dinput/gamepad.c
@@ -0,0 +1,768 @@
+/*  DirectInput Gamepad device
+ *
+ * Copyright 2024 BrunoSX
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include <string.h>
+#include <math.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winternl.h"
+#include "winuser.h"
+#include "winerror.h"
+#include "winreg.h"
+#include "dinput.h"
+#include "winsock2.h"
+#include "devguid.h"
+#include "hidusage.h"
+
+#include "dinput_private.h"
+#include "device_private.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dinput);
+
+#define SERVER_PORT 7948
+#define CLIENT_PORT 7947
+#define BUFFER_SIZE 64
+
+#define REQUEST_CODE_GET_GAMEPAD 8
+#define REQUEST_CODE_GET_GAMEPAD_STATE 9
+#define REQUEST_CODE_RELEASE_GAMEPAD 10
+
+#define MAPPER_TYPE_STANDARD 0
+#define MAPPER_TYPE_XINPUT 1
+
+#define IDX_BUTTON_A 0
+#define IDX_BUTTON_B 1
+#define IDX_BUTTON_X 2
+#define IDX_BUTTON_Y 3
+#define IDX_BUTTON_L1 4
+#define IDX_BUTTON_R1 5
+#define IDX_BUTTON_L2 10
+#define IDX_BUTTON_R2 11
+#define IDX_BUTTON_SELECT 6
+#define IDX_BUTTON_START 7
+#define IDX_BUTTON_L3 8
+#define IDX_BUTTON_R3 9
+
+struct gamepad_state 
+{
+    short buttons;
+    char dpad;
+    short thumb_lx;
+    short thumb_ly;
+    short thumb_rx;
+    short thumb_ry;    
+};
+
+struct gamepad
+{
+    struct dinput_device base;
+    struct gamepad_state state;
+};
+
+static const struct dinput_device_vtbl gamepad_vtbl;
+static SOCKET server_sock = INVALID_SOCKET;
+static BOOL winsock_loaded = FALSE;
+static int connected_gamepad_id = 0;
+static char mapper_type = MAPPER_TYPE_XINPUT;
+
+static inline struct gamepad *impl_from_IDirectInputDevice8W( IDirectInputDevice8W *iface )
+{
+    return CONTAINING_RECORD( CONTAINING_RECORD( iface, struct dinput_device, IDirectInputDevice8W_iface ), struct gamepad, base );
+}
+
+static void close_server_socket( void ) 
+{
+    if (server_sock != INVALID_SOCKET) 
+    {
+        closesocket( server_sock );
+        server_sock = INVALID_SOCKET;
+    }
+    
+    if (winsock_loaded) 
+    {
+        WSACleanup();
+        winsock_loaded = FALSE;
+    }    
+}
+
+static BOOL create_server_socket( void )
+{    
+    WSADATA wsa_data;
+    struct sockaddr_in server_addr;
+    const DWORD timeout = 2000;
+    const UINT reuse_addr = 1;
+    int res;
+    
+    close_server_socket();
+    
+    winsock_loaded = WSAStartup( MAKEWORD(2,2), &wsa_data ) == NO_ERROR;
+    if (!winsock_loaded) return FALSE;
+    
+    server_addr.sin_family = AF_INET;
+    server_addr.sin_addr.s_addr = inet_addr( "127.0.0.1" );
+    server_addr.sin_port = htons( SERVER_PORT );
+    
+    server_sock = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );
+    if (server_sock == INVALID_SOCKET) return FALSE;
+    
+    res = setsockopt( server_sock, SOL_SOCKET, SO_REUSEADDR, (const char *)&reuse_addr, sizeof(reuse_addr) );
+    if (res == SOCKET_ERROR) return FALSE;    
+     
+    res = setsockopt( server_sock, SOL_SOCKET, SO_RCVTIMEO, (const char *)&timeout, sizeof(timeout) );
+    if (res < 0) return FALSE;    
+
+    res = bind( server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr) );
+    if (res == SOCKET_ERROR) return FALSE;
+    
+    return TRUE;
+}
+
+static BOOL get_gamepad_request( BOOL notify, char* gamepad_name ) 
+{
+    int res, gamepad_id;
+    char buffer[BUFFER_SIZE];
+    struct sockaddr_in client_addr;
+    
+    client_addr.sin_family = AF_INET;
+    client_addr.sin_addr.s_addr = inet_addr( "127.0.0.1" );
+    client_addr.sin_port = htons( CLIENT_PORT );
+    
+    buffer[0] = REQUEST_CODE_GET_GAMEPAD;
+    buffer[1] = 0;
+    buffer[2] = notify ? 1 : 0;
+    res = sendto( server_sock, buffer, BUFFER_SIZE, 0, (struct sockaddr*)&client_addr, sizeof(client_addr) );
+    if (res == SOCKET_ERROR) return FALSE;
+    
+    res = recvfrom( server_sock, buffer, BUFFER_SIZE, 0, NULL, 0 );
+    if (res == SOCKET_ERROR || buffer[0] != REQUEST_CODE_GET_GAMEPAD) return FALSE;
+    
+    gamepad_id = *(int*)(buffer + 1);
+    if (gamepad_id == 0) 
+    {
+        connected_gamepad_id = 0;
+        return FALSE;
+    }
+    
+    connected_gamepad_id = gamepad_id;
+    mapper_type = buffer[5];
+    
+    if (gamepad_name != NULL) 
+    {
+        int name_len;
+        name_len = *(int*)(buffer + 6);
+        memcpy( gamepad_name, buffer + 10, name_len );
+        gamepad_name[name_len] = '\0';
+    }
+    
+    return TRUE;
+}
+
+static LONG scale_value( LONG value, struct object_properties *properties )
+{
+    LONG log_min, log_max, phy_min, phy_max;
+    log_min = properties->logical_min;
+    log_max = properties->logical_max;
+    phy_min = properties->range_min;
+    phy_max = properties->range_max;
+
+    return phy_min + MulDiv( value - log_min, phy_max - phy_min, log_max - log_min );
+}
+
+static LONG scale_axis_value( LONG value, struct object_properties *properties )
+{
+    LONG log_ctr, log_min, log_max, phy_ctr, phy_min, phy_max;
+    log_min = properties->logical_min;
+    log_max = properties->logical_max;
+    phy_min = properties->range_min;
+    phy_max = properties->range_max;
+
+    if (phy_min == 0) phy_ctr = phy_max >> 1;
+    else phy_ctr = round( (phy_min + phy_max) / 2.0 );
+    if (log_min == 0) log_ctr = log_max >> 1;
+    else log_ctr = round( (log_min + log_max) / 2.0 );
+
+    value -= log_ctr;
+    if (value <= 0)
+    {
+        log_max = MulDiv( log_min - log_ctr, properties->deadzone, 10000 );
+        log_min = MulDiv( log_min - log_ctr, properties->saturation, 10000 );
+        phy_max = phy_ctr;
+    }
+    else
+    {
+        log_min = MulDiv( log_max - log_ctr, properties->deadzone, 10000 );
+        log_max = MulDiv( log_max - log_ctr, properties->saturation, 10000 );
+        phy_min = phy_ctr;
+    }
+
+    if (value <= log_min) return phy_min;
+    if (value >= log_max) return phy_max;
+    return phy_min + MulDiv( value - log_min, phy_max - phy_min, log_max - log_min );
+}
+
+static void gamepad_handle_input( IDirectInputDevice8W *iface, short thumb_lx, short thumb_ly, short thumb_rx, short thumb_ry, short buttons, char dpad ) 
+{
+    int i, j, index;
+    DWORD time, seq;
+    BOOL notify = FALSE;
+    struct gamepad *impl = impl_from_IDirectInputDevice8W( iface );
+    DIJOYSTATE *state = (DIJOYSTATE *)impl->base.device_state;
+    
+    time = GetCurrentTime();
+    seq = impl->base.dinput->evsequence++;    
+    
+    if (mapper_type == MAPPER_TYPE_STANDARD) 
+    {
+        if (thumb_lx != impl->state.thumb_lx)
+        {
+            impl->state.thumb_lx = thumb_lx;
+            index = dinput_device_object_index_from_id( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 0 ) );
+            state->lX = scale_axis_value( thumb_lx, impl->base.object_properties + index );
+            queue_event( iface, index, state->lX, time, seq );
+            notify = TRUE;
+        }
+        
+        if (thumb_ly != impl->state.thumb_ly) 
+        {
+            impl->state.thumb_ly = thumb_ly;
+            index = dinput_device_object_index_from_id( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 1 ) );
+            state->lY = scale_axis_value( thumb_ly, impl->base.object_properties + index );        
+            queue_event( iface, index, state->lY, time, seq );
+            notify = TRUE;
+        }
+        
+        if (thumb_rx != impl->state.thumb_rx) 
+        {
+            impl->state.thumb_rx = thumb_rx;
+            index = dinput_device_object_index_from_id( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 2 ) );
+            state->lZ = scale_axis_value( thumb_rx, impl->base.object_properties + index );
+            queue_event( iface, index, state->lZ, time, seq );
+            notify = TRUE;
+        }
+        
+        if (thumb_ry != impl->state.thumb_ry) 
+        {
+            impl->state.thumb_ry = thumb_ry;
+            index = dinput_device_object_index_from_id( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 3 ) );
+            state->lRz = scale_axis_value( thumb_ry, impl->base.object_properties + index );
+            queue_event( iface, index, state->lRz, time, seq );
+            notify = TRUE;
+        }
+        
+        if (buttons != impl->state.buttons) 
+        {
+            impl->state.buttons = buttons;
+            for (i = 0, j = 0; i < 12; i++)
+            {
+                switch (i)
+                {
+                case IDX_BUTTON_A: j = 1; break;
+                case IDX_BUTTON_B: j = 2; break;
+                case IDX_BUTTON_X: j = 0; break;
+                case IDX_BUTTON_Y: j = 3; break;
+                case IDX_BUTTON_L1: j = 4; break;
+                case IDX_BUTTON_R1: j = 5; break;
+                case IDX_BUTTON_L2: j = 6; break;
+                case IDX_BUTTON_R2: j = 7; break;
+                case IDX_BUTTON_SELECT: j = 8; break;
+                case IDX_BUTTON_START: j = 9; break;
+                case IDX_BUTTON_L3: j = 10; break;
+                case IDX_BUTTON_R3: j = 11; break;                
+                }
+                
+                state->rgbButtons[j] = (buttons & (1<<i)) ? 0x80 : 0x00;
+                index = dinput_device_object_index_from_id( iface, DIDFT_BUTTON | DIDFT_MAKEINSTANCE( j ) );
+                queue_event( iface, index, state->rgbButtons[j], time, seq );    
+            }
+            notify = TRUE;        
+        }
+        
+        if (dpad != impl->state.dpad) 
+        {
+            impl->state.dpad = dpad;
+            index = dinput_device_object_index_from_id( iface, DIDFT_POV | DIDFT_MAKEINSTANCE( 0 ) );
+            state->rgdwPOV[0] = dpad != -1 ? dpad * 4500 : -1;
+            queue_event( iface, index, state->rgdwPOV[0], time, seq );
+            notify = TRUE;
+        }        
+    }
+    else if (mapper_type == MAPPER_TYPE_XINPUT) 
+    {
+        if (thumb_lx != impl->state.thumb_lx) 
+        {
+            impl->state.thumb_lx = thumb_lx;
+            index = dinput_device_object_index_from_id( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 0 ) );
+            state->lX = scale_axis_value( thumb_lx, impl->base.object_properties + index );
+            queue_event( iface, index, state->lX, time, seq );
+            notify = TRUE;
+        }
+        
+        if (thumb_ly != impl->state.thumb_ly) 
+        {
+            impl->state.thumb_ly = thumb_ly;
+            index = dinput_device_object_index_from_id( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 1 ) );
+            state->lY = scale_axis_value( thumb_ly, impl->base.object_properties + index );        
+            queue_event( iface, index, state->lY, time, seq );
+            notify = TRUE;
+        }
+        
+        if (thumb_rx != impl->state.thumb_rx) 
+        {
+            impl->state.thumb_rx = thumb_rx;
+            index = dinput_device_object_index_from_id( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 3 ) );
+            state->lRx = scale_axis_value( thumb_rx, impl->base.object_properties + index );
+            queue_event( iface, index, state->lRx, time, seq );
+            notify = TRUE;
+        }
+        
+        if (thumb_ry != impl->state.thumb_ry) 
+        {
+            impl->state.thumb_ry = thumb_ry;
+            index = dinput_device_object_index_from_id( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 4 ) );
+            state->lRy = scale_axis_value( thumb_ry, impl->base.object_properties + index );
+            queue_event( iface, index, state->lRy, time, seq );
+            notify = TRUE;
+        }
+        
+        if (buttons != impl->state.buttons) 
+        {
+            impl->state.buttons = buttons;
+            for (i = 0; i < 10; i++)
+            {
+                state->rgbButtons[i] = (buttons & (1<<i)) ? 0x80 : 0x00;
+                index = dinput_device_object_index_from_id( iface, DIDFT_BUTTON | DIDFT_MAKEINSTANCE( i ) );
+                queue_event( iface, index, state->rgbButtons[i], time, seq );    
+            }
+            
+            index = dinput_device_object_index_from_id( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 2 ) );
+            state->lZ = scale_value( (buttons & (1<<10)) ? 32767 : ((buttons & (1<<11)) ? -32768 : 0), impl->base.object_properties + index );
+            queue_event( iface, index, state->lZ, time, seq );
+            notify = TRUE;        
+        }
+        
+        if (dpad != impl->state.dpad) 
+        {
+            impl->state.dpad = dpad;
+            index = dinput_device_object_index_from_id( iface, DIDFT_POV | DIDFT_MAKEINSTANCE( 0 ) );
+            state->rgdwPOV[0] = dpad != -1 ? dpad * 4500 : -1;
+            queue_event( iface, index, state->rgdwPOV[0], time, seq );
+            notify = TRUE;
+        }        
+    }
+    
+    if (notify && impl->base.hEvent) SetEvent( impl->base.hEvent );
+}
+
+static void release_gamepad_request( void ) 
+{
+    char buffer[BUFFER_SIZE];
+    struct sockaddr_in client_addr;
+    int client_addr_len;
+    
+    client_addr.sin_family = AF_INET;
+    client_addr.sin_addr.s_addr = inet_addr( "127.0.0.1" );
+    client_addr.sin_port = htons( CLIENT_PORT );
+    client_addr_len = sizeof(client_addr);
+    
+    buffer[0] = REQUEST_CODE_RELEASE_GAMEPAD;
+    sendto( server_sock, buffer, BUFFER_SIZE, 0, (struct sockaddr*)&client_addr, client_addr_len );
+}
+
+HRESULT gamepad_enum_device( DWORD type, DWORD flags, DIDEVICEINSTANCEW *instance, DWORD version )
+{   
+    DWORD size;
+    char gamepad_name[64];
+
+    TRACE( "type %#lx, flags %#lx, instance %p, version %#lx.\n", type, flags, instance, version );
+    
+    if (!create_server_socket() || !get_gamepad_request( FALSE, gamepad_name )) return DIERR_INPUTLOST;
+    
+    size = instance->dwSize;
+    memset( instance, 0, size );
+    instance->dwSize = size;
+    instance->guidInstance = GUID_Joystick;
+    instance->guidProduct = GUID_Joystick;
+    instance->guidProduct.Data1 = MAKELONG( 0x045e, 0x028e );
+    if (version >= 0x0800) instance->dwDevType = DIDEVTYPE_HID | DI8DEVTYPE_GAMEPAD | (DI8DEVTYPEGAMEPAD_STANDARD << 8);
+    else instance->dwDevType = DIDEVTYPE_HID | DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_GAMEPAD << 8);
+    instance->wUsagePage = HID_USAGE_PAGE_GENERIC;
+    instance->wUsage = HID_USAGE_GENERIC_GAMEPAD;
+    MultiByteToWideChar( CP_ACP, 0, gamepad_name, -1, instance->tszInstanceName, MAX_PATH );
+    MultiByteToWideChar( CP_ACP, 0, gamepad_name, -1, instance->tszProductName, MAX_PATH );
+    
+    return DI_OK;
+}
+
+static BOOL init_object_properties( struct dinput_device *device, UINT index, struct hid_value_caps *caps,
+                                    const DIDEVICEOBJECTINSTANCEW *instance, void *data )
+{
+    struct object_properties *properties;
+    
+    if (index == -1) return DIENUM_STOP;
+    properties = device->object_properties + index;
+
+    properties->logical_min = -32768;
+    properties->logical_max = 32767;
+    properties->range_min = 0;
+    properties->range_max = 65535;
+    properties->saturation = 10000;
+    properties->granularity = 1;
+
+    return DIENUM_CONTINUE;
+}
+
+static void gamepad_release( IDirectInputDevice8W *iface )
+{
+    struct gamepad *impl = impl_from_IDirectInputDevice8W( iface );
+    CloseHandle( impl->base.read_event );
+}
+
+static HRESULT gamepad_read( IDirectInputDevice8W *iface )
+{   
+    int res;
+    char buffer[BUFFER_SIZE];
+    
+    if (server_sock == INVALID_SOCKET) return DI_OK;
+    res = recvfrom( server_sock, buffer, BUFFER_SIZE, 0, NULL, 0 );
+    if (res == SOCKET_ERROR) return DI_OK;
+    
+    if (buffer[0] == REQUEST_CODE_GET_GAMEPAD_STATE && buffer[1] == 1) 
+    {
+        int gamepad_id;
+        char dpad;
+        short buttons, thumb_lx, thumb_ly, thumb_rx, thumb_ry;        
+        
+        gamepad_id = *(int*)(buffer + 2);
+        if (gamepad_id != connected_gamepad_id) return DI_OK;
+    
+        buttons = *(short*)(buffer + 6);
+        dpad = buffer[8];
+    
+        thumb_lx = *(short*)(buffer + 9);
+        thumb_ly = *(short*)(buffer + 11);
+        thumb_rx = *(short*)(buffer + 13);
+        thumb_ry = *(short*)(buffer + 15);
+    
+        gamepad_handle_input( iface, thumb_lx, thumb_ly, thumb_rx, thumb_ry, buttons, dpad );
+    }
+    return DI_OK;
+}
+
+static HRESULT gamepad_acquire( IDirectInputDevice8W *iface )
+{
+    struct gamepad *impl = impl_from_IDirectInputDevice8W( iface );
+    get_gamepad_request( TRUE, NULL );
+    SetEvent( impl->base.read_event );
+    return DI_OK;
+}
+
+static HRESULT gamepad_unacquire( IDirectInputDevice8W *iface )
+{
+    struct gamepad *impl = impl_from_IDirectInputDevice8W( iface );
+    WaitForSingleObject( impl->base.read_event, INFINITE );
+    
+    release_gamepad_request();
+    close_server_socket();
+    return DI_OK;
+}
+
+static BOOL try_enum_object( struct dinput_device *impl, const DIPROPHEADER *filter, DWORD flags, enum_object_callback callback,
+                             UINT index, DIDEVICEOBJECTINSTANCEW *instance, void *data )
+{
+    if (flags != DIDFT_ALL && !(flags & DIDFT_GETTYPE( instance->dwType ))) return DIENUM_CONTINUE;
+
+    switch (filter->dwHow)
+    {
+    case DIPH_DEVICE:
+        return callback( impl, index, NULL, instance, data );
+    case DIPH_BYOFFSET:
+        if (filter->dwObj != instance->dwOfs) return DIENUM_CONTINUE;
+        return callback( impl, index, NULL, instance, data );
+    case DIPH_BYID:
+        if ((filter->dwObj & 0x00ffffff) != (instance->dwType & 0x00ffffff)) return DIENUM_CONTINUE;
+        return callback( impl, index, NULL, instance, data );
+    }
+
+    return DIENUM_CONTINUE;
+}
+
+static void get_device_objects( int *instance_count, DIDEVICEOBJECTINSTANCEW **out ) 
+{
+    int i, index = 0;
+    
+    *instance_count = 0;
+    *out = NULL;
+
+    if (mapper_type == MAPPER_TYPE_STANDARD) 
+    {
+        DIDEVICEOBJECTINSTANCEW instances[17];
+        *instance_count = 17;
+        
+        instances[index].guidType = GUID_XAxis;
+        instances[index].dwOfs = DIJOFS_X;
+        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 0 );
+        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
+        swprintf( instances[index].tszName, MAX_PATH, L"X Axis" );
+        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
+        instances[index].wUsage = HID_USAGE_GENERIC_X;
+        index++;
+        
+        instances[index].guidType = GUID_YAxis;
+        instances[index].dwOfs = DIJOFS_Y;
+        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 1 );
+        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
+        swprintf( instances[index].tszName, MAX_PATH, L"Y Axis" );
+        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
+        instances[index].wUsage = HID_USAGE_GENERIC_Y;    
+        index++;
+        
+        instances[index].guidType = GUID_ZAxis;
+        instances[index].dwOfs = DIJOFS_Z;
+        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 2 );
+        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
+        swprintf( instances[index].tszName, MAX_PATH, L"Z Axis" );
+        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
+        instances[index].wUsage = HID_USAGE_GENERIC_Z;    
+        index++;    
+
+        instances[index].guidType = GUID_RzAxis;
+        instances[index].dwOfs = DIJOFS_RZ;
+        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 3 );
+        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
+        swprintf( instances[index].tszName, MAX_PATH, L"Rz Axis" );
+        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
+        instances[index].wUsage = HID_USAGE_GENERIC_RZ;    
+        index++;
+        
+        for (i = 0; i < 12; i++) 
+        {
+            instances[index].guidType = GUID_Button,
+            instances[index].dwOfs = DIJOFS_BUTTON( i ),
+            instances[index].dwType = DIDFT_BUTTON | DIDFT_MAKEINSTANCE( i ),
+            swprintf( instances[index].tszName, MAX_PATH, L"Button %d", i );
+            instances[index].wUsagePage = HID_USAGE_PAGE_BUTTON;
+            instances[index].wUsage = i + 1;
+            index++;
+        }
+        
+        instances[index].guidType = GUID_POV;
+        instances[index].dwOfs = DIJOFS_POV( 0 );
+        instances[index].dwType = DIDFT_POV | DIDFT_MAKEINSTANCE( 0 );
+        swprintf( instances[index].tszName, MAX_PATH, L"POV" );
+        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
+        instances[index].wUsage = HID_USAGE_GENERIC_HATSWITCH;
+        
+        *out = instances;
+    }
+    else if (mapper_type == MAPPER_TYPE_XINPUT) 
+    {
+        DIDEVICEOBJECTINSTANCEW instances[16];
+        *instance_count = 16;
+        
+        instances[index].guidType = GUID_XAxis;
+        instances[index].dwOfs = DIJOFS_X;
+        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 0 );
+        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
+        swprintf( instances[index].tszName, MAX_PATH, L"X Axis" );
+        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
+        instances[index].wUsage = HID_USAGE_GENERIC_X;
+        index++;
+        
+        instances[index].guidType = GUID_YAxis;
+        instances[index].dwOfs = DIJOFS_Y;
+        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 1 );
+        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
+        swprintf( instances[index].tszName, MAX_PATH, L"Y Axis" );
+        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
+        instances[index].wUsage = HID_USAGE_GENERIC_Y;
+        index++;
+        
+        instances[index].guidType = GUID_ZAxis;
+        instances[index].dwOfs = DIJOFS_Z;
+        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 2 );
+        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
+        swprintf( instances[index].tszName, MAX_PATH, L"Z Axis" );
+        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
+        instances[index].wUsage = HID_USAGE_GENERIC_Z;
+        index++;    
+
+        instances[index].guidType = GUID_RxAxis;
+        instances[index].dwOfs = DIJOFS_RX;
+        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 3 );
+        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
+        swprintf( instances[index].tszName, MAX_PATH, L"Rx Axis" );
+        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
+        instances[index].wUsage = HID_USAGE_GENERIC_RX;
+        index++;
+
+        instances[index].guidType = GUID_RyAxis;
+        instances[index].dwOfs = DIJOFS_RY;
+        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 4 );
+        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
+        swprintf( instances[index].tszName, MAX_PATH, L"Ry Axis" );
+        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
+        instances[index].wUsage = HID_USAGE_GENERIC_RY;    
+        index++;
+        
+        for (i = 0; i < 10; i++) 
+        {
+            instances[index].guidType = GUID_Button,
+            instances[index].dwOfs = DIJOFS_BUTTON( i ),
+            instances[index].dwType = DIDFT_BUTTON | DIDFT_MAKEINSTANCE( i ),
+            swprintf( instances[index].tszName, MAX_PATH, L"Button %d", i );
+            instances[index].wUsagePage = HID_USAGE_PAGE_BUTTON;
+            instances[index].wUsage = i + 1;
+            index++;
+        }
+        
+        instances[index].guidType = GUID_POV;
+        instances[index].dwOfs = DIJOFS_POV( 0 );
+        instances[index].dwType = DIDFT_POV | DIDFT_MAKEINSTANCE( 0 );
+        swprintf( instances[index].tszName, MAX_PATH, L"POV" );
+        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
+        instances[index].wUsage = HID_USAGE_GENERIC_HATSWITCH;
+        
+        *out = instances;
+    }
+}
+
+static HRESULT gamepad_enum_objects( IDirectInputDevice8W *iface, const DIPROPHEADER *filter,
+                                     DWORD flags, enum_object_callback callback, void *context )
+{
+    struct gamepad *impl = impl_from_IDirectInputDevice8W( iface );
+    int instance_count;
+    DIDEVICEOBJECTINSTANCEW* instances;
+    BOOL ret;
+    DWORD i;
+    
+    get_device_objects( &instance_count, &instances );
+
+    for (i = 0; i < instance_count; i++)
+    {
+        DIDEVICEOBJECTINSTANCEW *instance = instances + i;
+        instance->dwSize = sizeof(DIDEVICEOBJECTINSTANCEW);
+        instance->wReportId = 1;
+        
+        ret = try_enum_object( &impl->base, filter, flags, callback, i, instance, context );
+        if (ret != DIENUM_CONTINUE) return DIENUM_STOP;
+    }
+
+    return DIENUM_CONTINUE;
+}
+
+static HRESULT gamepad_get_property( IDirectInputDevice8W *iface, DWORD property,
+                                     DIPROPHEADER *header, const DIDEVICEOBJECTINSTANCEW *instance )
+{
+    struct gamepad *impl = impl_from_IDirectInputDevice8W( iface );
+    
+    switch (property)
+    {
+    case (DWORD_PTR)DIPROP_PRODUCTNAME:
+    {
+        DIPROPSTRING *value = (DIPROPSTRING *)header;
+        lstrcpynW( value->wsz, impl->base.instance.tszProductName, MAX_PATH );
+        return DI_OK;
+    }
+    case (DWORD_PTR)DIPROP_INSTANCENAME:
+    {
+        DIPROPSTRING *value = (DIPROPSTRING *)header;
+        lstrcpynW( value->wsz, impl->base.instance.tszInstanceName, MAX_PATH );
+        return DI_OK;
+    }
+    case (DWORD_PTR)DIPROP_VIDPID:
+    {
+        DIPROPDWORD *value = (DIPROPDWORD *)header;
+        value->dwData = MAKELONG( 0x045e, 0x028e );
+        return DI_OK;
+    }
+    case (DWORD_PTR)DIPROP_JOYSTICKID:
+    {
+        DIPROPDWORD *value = (DIPROPDWORD *)header;
+        value->dwData = connected_gamepad_id;
+        return DI_OK;
+    }
+    case (DWORD_PTR)DIPROP_GUIDANDPATH:
+    {
+        DIPROPGUIDANDPATH *value = (DIPROPGUIDANDPATH *)header;
+        value->guidClass = GUID_DEVCLASS_HIDCLASS;
+        lstrcpynW( value->wszPath, L"virtual#vid_045e&pid_028e&ig_00", MAX_PATH );
+        return DI_OK;
+    }
+    }
+
+    return DIERR_UNSUPPORTED;
+}
+
+HRESULT gamepad_create_device( struct dinput *dinput, const GUID *guid, IDirectInputDevice8W **out )
+{
+    static const DIPROPHEADER filter =
+    {
+        .dwSize = sizeof(filter),
+        .dwHeaderSize = sizeof(filter),
+        .dwHow = DIPH_DEVICE,
+    };
+    struct gamepad *impl;
+    HRESULT hr;
+    
+    TRACE( "dinput %p, guid %s, out %p.\n", dinput, debugstr_guid( guid ), out );
+
+    *out = NULL;
+    if (!IsEqualGUID( &GUID_Joystick, guid )) return DIERR_DEVICENOTREG;
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+    dinput_device_init( &impl->base, &gamepad_vtbl, guid, dinput );
+    impl->base.crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": struct gamepad*->base.crit");
+    impl->base.read_event = CreateEventW( NULL, TRUE, FALSE, NULL );
+
+    gamepad_enum_device( 0, 0, &impl->base.instance, dinput->dwVersion );
+    impl->base.caps.dwDevType = impl->base.instance.dwDevType;
+    impl->base.caps.dwFirmwareRevision = 100;
+    impl->base.caps.dwHardwareRevision = 100;
+    impl->base.dwCoopLevel = DISCL_NONEXCLUSIVE | DISCL_BACKGROUND;
+    
+    if (FAILED(hr = dinput_device_init_device_format( &impl->base.IDirectInputDevice8W_iface ))) goto failed;
+    gamepad_enum_objects( &impl->base.IDirectInputDevice8W_iface, &filter, DIDFT_AXIS, init_object_properties, NULL );
+
+    *out = &impl->base.IDirectInputDevice8W_iface;
+    return DI_OK;
+    
+failed:
+    IDirectInputDevice_Release( &impl->base.IDirectInputDevice8W_iface );
+    return hr;    
+}
+
+static const struct dinput_device_vtbl gamepad_vtbl =
+{
+    gamepad_release,
+    NULL,
+    gamepad_read,
+    gamepad_acquire,
+    gamepad_unacquire,
+    gamepad_enum_objects,
+    gamepad_get_property,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+};
\ No newline at end of file
diff --git a/dlls/dinput/tests/driver_bus.spec b/dlls/dinput/tests/driver_bus.spec
new file mode 100755
index 0000000..ad33444
--- /dev/null
+++ b/dlls/dinput/tests/driver_bus.spec
@@ -0,0 +1 @@
+# nothing here yet
diff --git a/dlls/dinput/tests/driver_hid.spec b/dlls/dinput/tests/driver_hid.spec
new file mode 100755
index 0000000..ad33444
--- /dev/null
+++ b/dlls/dinput/tests/driver_hid.spec
@@ -0,0 +1 @@
+# nothing here yet
diff --git a/dlls/dinput/tests/driver_hid_poll.spec b/dlls/dinput/tests/driver_hid_poll.spec
new file mode 100755
index 0000000..ad33444
--- /dev/null
+++ b/dlls/dinput/tests/driver_hid_poll.spec
@@ -0,0 +1 @@
+# nothing here yet
diff --git a/dlls/dinput8/Makefile.in b/dlls/dinput8/Makefile.in
index f3f5fdc..45a5e72 100755
--- a/dlls/dinput8/Makefile.in
+++ b/dlls/dinput8/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = dinput8.dll
 IMPORTLIB = dinput8
-IMPORTS   = dinput8 dxguid uuid comctl32 ole32 user32 advapi32 hid setupapi
+IMPORTS   = dinput8 dxguid uuid comctl32 ole32 user32 advapi32 hid setupapi ws2_32
 EXTRADEFS = -DDIRECTINPUT_VERSION=0x0800
 PARENTSRC = ../dinput
 
@@ -16,4 +16,5 @@ SOURCES = \
 	joystick_hid.c \
 	keyboard.c \
 	mouse.c \
-	version.rc
+	version.rc \
+    gamepad.c
diff --git a/dlls/xinput1_1/Makefile.in b/dlls/xinput1_1/Makefile.in
index b5c13cd..b62e618 100755
--- a/dlls/xinput1_1/Makefile.in
+++ b/dlls/xinput1_1/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = xinput1_1.dll
-IMPORTS   = hid setupapi advapi32 user32
+IMPORTS   = hid setupapi advapi32 user32 ws2_32
 PARENTSRC = ../xinput1_3
 
 SOURCES = \
diff --git a/dlls/xinput1_2/Makefile.in b/dlls/xinput1_2/Makefile.in
index f49e8f5..d226175 100755
--- a/dlls/xinput1_2/Makefile.in
+++ b/dlls/xinput1_2/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = xinput1_2.dll
-IMPORTS   = hid setupapi advapi32 user32
+IMPORTS   = hid setupapi advapi32 user32 ws2_32
 PARENTSRC = ../xinput1_3
 
 SOURCES = \
diff --git a/dlls/xinput1_3/Makefile.in b/dlls/xinput1_3/Makefile.in
index 28d46d8..9c4f707 100755
--- a/dlls/xinput1_3/Makefile.in
+++ b/dlls/xinput1_3/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = xinput1_3.dll
 IMPORTLIB = xinput
-IMPORTS   = hid setupapi advapi32 user32
+IMPORTS   = hid setupapi advapi32 user32 ws2_32
 
 SOURCES = \
 	main.c \
diff --git a/dlls/xinput1_3/main.c b/dlls/xinput1_3/main.c
old mode 100755
new mode 100644
index 28f57e9..9d4832f
--- a/dlls/xinput1_3/main.c
+++ b/dlls/xinput1_3/main.c
@@ -3,6 +3,7 @@
  * Copyright 2008 Andrew Fenn
  * Copyright 2018 Aric Stewart
  * Copyright 2021 RÃ©mi Bernon for CodeWeavers
+ * Copyright 2024 BrunoSX 
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -32,23 +33,40 @@
 #include "wingdi.h"
 #include "winnls.h"
 #include "winternl.h"
+#include "winsock2.h"
 
 #include "dbt.h"
 #include "setupapi.h"
-#include "devpkey.h"
-#include "hidusage.h"
-#include "ddk/hidsdi.h"
 #include "initguid.h"
 #include "devguid.h"
 #include "xinput.h"
 
 #include "wine/debug.h"
 
-DEFINE_GUID(GUID_DEVINTERFACE_WINEXINPUT,0x6c53d5fd,0x6480,0x440f,0xb6,0x18,0x47,0x67,0x50,0xc5,0xe1,0xa6);
-
 /* Not defined in the headers, used only by XInputGetStateEx */
 #define XINPUT_GAMEPAD_GUIDE 0x0400
 
+#define SERVER_PORT 7949
+#define CLIENT_PORT 7947
+#define BUFFER_SIZE 64
+
+#define REQUEST_CODE_GET_GAMEPAD 8
+#define REQUEST_CODE_GET_GAMEPAD_STATE 9
+#define REQUEST_CODE_RELEASE_GAMEPAD 10
+
+#define IDX_BUTTON_A 0
+#define IDX_BUTTON_B 1
+#define IDX_BUTTON_X 2
+#define IDX_BUTTON_Y 3
+#define IDX_BUTTON_L1 4
+#define IDX_BUTTON_R1 5
+#define IDX_BUTTON_L2 10
+#define IDX_BUTTON_R2 11
+#define IDX_BUTTON_SELECT 6
+#define IDX_BUTTON_START 7
+#define IDX_BUTTON_L3 8
+#define IDX_BUTTON_R3 9
+
 WINE_DEFAULT_DEBUG_CHANNEL(xinput);
 
 struct xinput_controller
@@ -57,728 +75,316 @@ struct xinput_controller
     XINPUT_CAPABILITIES caps;
     XINPUT_STATE state;
     XINPUT_GAMEPAD last_keystroke;
-    XINPUT_VIBRATION vibration;
-    HANDLE device;
-    WCHAR device_path[MAX_PATH];
     BOOL enabled;
-
-    struct
-    {
-        PHIDP_PREPARSED_DATA preparsed;
-        HIDP_CAPS caps;
-        HIDP_VALUE_CAPS lx_caps;
-        HIDP_VALUE_CAPS ly_caps;
-        HIDP_VALUE_CAPS lt_caps;
-        HIDP_VALUE_CAPS rx_caps;
-        HIDP_VALUE_CAPS ry_caps;
-        HIDP_VALUE_CAPS rt_caps;
-
-        HANDLE read_event;
-        OVERLAPPED read_ovl;
-
-        char *input_report_buf;
-        char *output_report_buf;
-        char *feature_report_buf;
-
-        BYTE haptics_report;
-        HIDP_VALUE_CAPS haptics_rumble_caps;
-        HIDP_VALUE_CAPS haptics_buzz_caps;
-    } hid;
+    BOOL connected;
+    int id;
 };
 
-static struct xinput_controller controllers[XUSER_MAX_COUNT];
-static CRITICAL_SECTION_DEBUG controller_critsect_debug[XUSER_MAX_COUNT] =
+static struct xinput_controller controller;
+static CRITICAL_SECTION_DEBUG controller_critsect_debug = 
 {
-    {
-        0, 0, &controllers[0].crit,
-        { &controller_critsect_debug[0].ProcessLocksList, &controller_critsect_debug[0].ProcessLocksList },
-          0, 0, { (DWORD_PTR)(__FILE__ ": controllers[0].crit") }
-    },
-    {
-        0, 0, &controllers[1].crit,
-        { &controller_critsect_debug[1].ProcessLocksList, &controller_critsect_debug[1].ProcessLocksList },
-          0, 0, { (DWORD_PTR)(__FILE__ ": controllers[1].crit") }
-    },
-    {
-        0, 0, &controllers[2].crit,
-        { &controller_critsect_debug[2].ProcessLocksList, &controller_critsect_debug[2].ProcessLocksList },
-          0, 0, { (DWORD_PTR)(__FILE__ ": controllers[2].crit") }
-    },
-    {
-        0, 0, &controllers[3].crit,
-        { &controller_critsect_debug[3].ProcessLocksList, &controller_critsect_debug[3].ProcessLocksList },
-          0, 0, { (DWORD_PTR)(__FILE__ ": controllers[3].crit") }
-    },
+    0, 0, &controller.crit,
+    {&controller_critsect_debug.ProcessLocksList, &controller_critsect_debug.ProcessLocksList},
+    0, 0, {(DWORD_PTR)(__FILE__ ": controller.crit")}
 };
 
-static struct xinput_controller controllers[XUSER_MAX_COUNT] =
+static struct xinput_controller controller = 
 {
-    {{ &controller_critsect_debug[0], -1, 0, 0, 0, 0 }},
-    {{ &controller_critsect_debug[1], -1, 0, 0, 0, 0 }},
-    {{ &controller_critsect_debug[2], -1, 0, 0, 0, 0 }},
-    {{ &controller_critsect_debug[3], -1, 0, 0, 0, 0 }},
+    .crit = {&controller_critsect_debug, -1, 0, 0, 0, 0},
+    .enabled = FALSE,
+    .connected = FALSE,
+    .id = 0
 };
 
-static HMODULE xinput_instance;
 static HANDLE start_event;
-static HANDLE update_event;
-
-static BOOL find_opened_device(const WCHAR *device_path, int *free_slot)
-{
-    int i;
-
-    *free_slot = XUSER_MAX_COUNT;
-    for (i = XUSER_MAX_COUNT; i > 0; i--)
-    {
-        if (!controllers[i - 1].device) *free_slot = i - 1;
-        else if (!wcsicmp(device_path, controllers[i - 1].device_path)) return TRUE;
-    }
-    return FALSE;
+static BOOL thread_running = FALSE;
+
+static SOCKET server_sock = INVALID_SOCKET;
+static BOOL winsock_loaded = FALSE;
+static char xinput_min_index = 3;
+
+static void close_server_socket(void) 
+{
+    if (server_sock != INVALID_SOCKET) 
+    {
+        closesocket(server_sock);
+        server_sock = INVALID_SOCKET;
+    }
+    
+    if (winsock_loaded) 
+    {
+        WSACleanup();
+        winsock_loaded = FALSE;
+    }
+}
+
+static BOOL create_server_socket(void)
+{    
+    WSADATA wsa_data;
+    struct sockaddr_in server_addr;
+    const UINT reuse_addr = 1;
+    ULONG non_blocking = 1;
+    int res;
+    
+    close_server_socket();
+    
+    winsock_loaded = WSAStartup(MAKEWORD(2,2), &wsa_data) == NO_ERROR;
+    if (!winsock_loaded) return FALSE;
+    
+    server_addr.sin_family = AF_INET;
+    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
+    server_addr.sin_port = htons(SERVER_PORT);
+    
+    server_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+    if (server_sock == INVALID_SOCKET) return FALSE;
+    
+    res = setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, (const char *)&reuse_addr, sizeof(reuse_addr));
+    if (res == SOCKET_ERROR) return FALSE;
+    
+    ioctlsocket(server_sock, FIONBIO, &non_blocking);
+
+    res = bind(server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr));
+    if (res == SOCKET_ERROR) return FALSE;
+    
+    return TRUE;
 }
 
-static void check_value_caps(struct xinput_controller *controller, USHORT usage, HIDP_VALUE_CAPS *caps)
+static void get_gamepad_request(void)
 {
-    switch (usage)
-    {
-    case HID_USAGE_GENERIC_X: controller->hid.lx_caps = *caps; break;
-    case HID_USAGE_GENERIC_Y: controller->hid.ly_caps = *caps; break;
-    case HID_USAGE_GENERIC_Z: controller->hid.lt_caps = *caps; break;
-    case HID_USAGE_GENERIC_RX: controller->hid.rx_caps = *caps; break;
-    case HID_USAGE_GENERIC_RY: controller->hid.ry_caps = *caps; break;
-    case HID_USAGE_GENERIC_RZ: controller->hid.rt_caps = *caps; break;
-    }
+    char buffer[BUFFER_SIZE];
+    struct sockaddr_in client_addr;
+    
+    client_addr.sin_family = AF_INET;
+    client_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
+    client_addr.sin_port = htons(CLIENT_PORT);
+    
+    buffer[0] = REQUEST_CODE_GET_GAMEPAD;
+    buffer[1] = 1;
+    buffer[2] = 1;
+    sendto(server_sock, buffer, BUFFER_SIZE, 0, (struct sockaddr*)&client_addr, sizeof(client_addr));
 }
 
-static void check_waveform_caps(struct xinput_controller *controller, HANDLE device, PHIDP_PREPARSED_DATA preparsed,
-                                HIDP_LINK_COLLECTION_NODE *collections, HIDP_VALUE_CAPS *caps)
+static void release_gamepad_request(void)
 {
-    USHORT count, report_len = controller->hid.caps.FeatureReportByteLength;
-    char *report_buf = controller->hid.feature_report_buf;
-    ULONG parent = caps->LinkCollection, waveform = 0;
-    HIDP_VALUE_CAPS value_caps;
-    USAGE_AND_PAGE phy_usages;
-    NTSTATUS status;
-
-    while (collections[parent].LinkUsagePage != HID_USAGE_PAGE_HAPTICS ||
-           collections[parent].LinkUsage != HID_USAGE_HAPTICS_SIMPLE_CONTROLLER)
-        if (!(parent = collections[parent].Parent)) break;
-
-    if (collections[parent].LinkUsagePage != HID_USAGE_PAGE_HAPTICS ||
-        collections[parent].LinkUsage != HID_USAGE_HAPTICS_SIMPLE_CONTROLLER)
-    {
-        WARN("Failed to find haptics simple controller collection\n");
-        return;
-    }
-    phy_usages.UsagePage = collections[collections[parent].Parent].LinkUsagePage;
-    phy_usages.Usage = collections[collections[parent].Parent].LinkUsage;
-
-    status = HidP_InitializeReportForID(HidP_Feature, caps->ReportID, preparsed, report_buf, report_len);
-    if (status != HIDP_STATUS_SUCCESS) WARN("HidP_InitializeReportForID returned %#lx\n", status);
-    if (!HidD_GetFeature(device, report_buf, report_len))
-    {
-        WARN("Failed to get waveform list report, error %lu\n", GetLastError());
-        return;
-    }
-
-    status = HidP_GetUsageValue(HidP_Feature, caps->UsagePage, caps->LinkCollection, caps->NotRange.Usage,
-                                &waveform, preparsed, report_buf, report_len);
-    if (status != HIDP_STATUS_SUCCESS) WARN("HidP_GetUsageValue returned %#lx\n", status);
-
-    count = 1;
-    status = HidP_GetSpecificValueCaps(HidP_Output, HID_USAGE_PAGE_HAPTICS, parent, HID_USAGE_HAPTICS_INTENSITY,
-                                       &value_caps, &count, preparsed);
-    if (status != HIDP_STATUS_SUCCESS || !count) WARN("Failed to get waveform intensity caps, status %#lx\n", status);
-    else if (phy_usages.UsagePage == HID_USAGE_PAGE_GENERIC && phy_usages.Usage == HID_USAGE_GENERIC_Z)
-        TRACE( "Ignoring left rumble caps\n" );
-    else if (phy_usages.UsagePage == HID_USAGE_PAGE_GENERIC && phy_usages.Usage == HID_USAGE_GENERIC_RZ)
-        TRACE( "Ignoring right rumble caps\n" );
-    else if (waveform == HID_USAGE_HAPTICS_WAVEFORM_RUMBLE)
-    {
-        TRACE("Found rumble caps, report %u collection %u\n", value_caps.ReportID, value_caps.LinkCollection);
-        controller->hid.haptics_report = value_caps.ReportID;
-        controller->hid.haptics_rumble_caps = value_caps;
-    }
-    else if (waveform == HID_USAGE_HAPTICS_WAVEFORM_BUZZ)
-    {
-        TRACE("Found buzz caps, report %u collection %u\n", value_caps.ReportID, value_caps.LinkCollection);
-        controller->hid.haptics_report = value_caps.ReportID;
-        controller->hid.haptics_buzz_caps = value_caps;
-    }
-    else FIXME("Unsupported waveform type %#lx\n", waveform);
+    char buffer[BUFFER_SIZE];
+    struct sockaddr_in client_addr;
+    
+    client_addr.sin_family = AF_INET;
+    client_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
+    client_addr.sin_port = htons(CLIENT_PORT);
+    
+    buffer[0] = REQUEST_CODE_RELEASE_GAMEPAD;
+    sendto(server_sock, buffer, BUFFER_SIZE, 0, (struct sockaddr*)&client_addr, sizeof(client_addr));
 }
 
-static BOOL controller_check_caps(struct xinput_controller *controller, HANDLE device, PHIDP_PREPARSED_DATA preparsed)
+static BOOL controller_check_caps(void)
 {
-    USHORT caps_count = 0, waveform_caps_count = 0;
-    XINPUT_CAPABILITIES *caps = &controller->caps;
-    HIDP_LINK_COLLECTION_NODE *collections;
-    HIDP_VALUE_CAPS waveform_caps[8];
-    HIDP_BUTTON_CAPS *button_caps;
-    ULONG collections_count = 0;
-    HIDP_VALUE_CAPS *value_caps;
-    int i, u, button_count = 0;
-    NTSTATUS status;
-
-    /* Count buttons */
+    XINPUT_CAPABILITIES *caps = &controller.caps;
     memset(caps, 0, sizeof(XINPUT_CAPABILITIES));
-
-    if (!(button_caps = malloc(sizeof(*button_caps) * controller->hid.caps.NumberInputButtonCaps))) return FALSE;
-    status = HidP_GetButtonCaps(HidP_Input, button_caps, &controller->hid.caps.NumberInputButtonCaps, preparsed);
-    if (status != HIDP_STATUS_SUCCESS) WARN("HidP_GetButtonCaps returned %#lx\n", status);
-    else for (i = 0; i < controller->hid.caps.NumberInputButtonCaps; i++)
-    {
-        if (button_caps[i].UsagePage != HID_USAGE_PAGE_BUTTON)
-            continue;
-        if (button_caps[i].IsRange)
-            button_count = max(button_count, button_caps[i].Range.UsageMax);
-        else
-            button_count = max(button_count, button_caps[i].NotRange.Usage);
-    }
-    free(button_caps);
-    if (button_count < 11)
-        WARN("Too few buttons, continuing anyway\n");
+    
     caps->Gamepad.wButtons = 0xffff;
-
-    if (!(value_caps = malloc(sizeof(*value_caps) * controller->hid.caps.NumberInputValueCaps))) return FALSE;
-    status = HidP_GetValueCaps(HidP_Input, value_caps, &controller->hid.caps.NumberInputValueCaps, preparsed);
-    if (status != HIDP_STATUS_SUCCESS) WARN("HidP_GetValueCaps returned %#lx\n", status);
-    else for (i = 0; i < controller->hid.caps.NumberInputValueCaps; i++)
-    {
-        HIDP_VALUE_CAPS *caps = value_caps + i;
-        if (caps->UsagePage != HID_USAGE_PAGE_GENERIC) continue;
-        if (!caps->IsRange) check_value_caps(controller, caps->NotRange.Usage, caps);
-        else for (u = caps->Range.UsageMin; u <=caps->Range.UsageMax; u++) check_value_caps(controller, u, value_caps + i);
-    }
-    free(value_caps);
-
-    if (!controller->hid.lt_caps.UsagePage) WARN("Missing axis LeftTrigger\n");
-    else caps->Gamepad.bLeftTrigger = (1u << (sizeof(caps->Gamepad.bLeftTrigger) + 1)) - 1;
-    if (!controller->hid.rt_caps.UsagePage) WARN("Missing axis RightTrigger\n");
-    else caps->Gamepad.bRightTrigger = (1u << (sizeof(caps->Gamepad.bRightTrigger) + 1)) - 1;
-    if (!controller->hid.lx_caps.UsagePage) WARN("Missing axis ThumbLX\n");
-    else caps->Gamepad.sThumbLX = (1u << (sizeof(caps->Gamepad.sThumbLX) + 1)) - 1;
-    if (!controller->hid.ly_caps.UsagePage) WARN("Missing axis ThumbLY\n");
-    else caps->Gamepad.sThumbLY = (1u << (sizeof(caps->Gamepad.sThumbLY) + 1)) - 1;
-    if (!controller->hid.rx_caps.UsagePage) WARN("Missing axis ThumbRX\n");
-    else caps->Gamepad.sThumbRX = (1u << (sizeof(caps->Gamepad.sThumbRX) + 1)) - 1;
-    if (!controller->hid.ry_caps.UsagePage) WARN("Missing axis ThumbRY\n");
-    else caps->Gamepad.sThumbRY = (1u << (sizeof(caps->Gamepad.sThumbRY) + 1)) - 1;
+    caps->Gamepad.bLeftTrigger = (1u << (sizeof(caps->Gamepad.bLeftTrigger) + 1)) - 1;
+    caps->Gamepad.bRightTrigger = (1u << (sizeof(caps->Gamepad.bRightTrigger) + 1)) - 1;
+    caps->Gamepad.sThumbLX = (1u << (sizeof(caps->Gamepad.sThumbLX) + 1)) - 1;
+    caps->Gamepad.sThumbLY = (1u << (sizeof(caps->Gamepad.sThumbLY) + 1)) - 1;
+    caps->Gamepad.sThumbRX = (1u << (sizeof(caps->Gamepad.sThumbRX) + 1)) - 1;
+    caps->Gamepad.sThumbRY = (1u << (sizeof(caps->Gamepad.sThumbRY) + 1)) - 1;
 
     caps->Type = XINPUT_DEVTYPE_GAMEPAD;
     caps->SubType = XINPUT_DEVSUBTYPE_GAMEPAD;
-
-    collections_count = controller->hid.caps.NumberLinkCollectionNodes;
-    if (!(collections = malloc(sizeof(*collections) * controller->hid.caps.NumberLinkCollectionNodes))) return FALSE;
-    status = HidP_GetLinkCollectionNodes(collections, &collections_count, preparsed);
-    if (status != HIDP_STATUS_SUCCESS) WARN("HidP_GetLinkCollectionNodes returned %#lx\n", status);
-    else for (i = 0; i < collections_count; ++i)
-    {
-        if (collections[i].LinkUsagePage != HID_USAGE_PAGE_HAPTICS) continue;
-        if (collections[i].LinkUsage == HID_USAGE_HAPTICS_WAVEFORM_LIST)
-        {
-            caps_count = ARRAY_SIZE(waveform_caps) - waveform_caps_count;
-            value_caps = waveform_caps + waveform_caps_count;
-            status = HidP_GetSpecificValueCaps(HidP_Feature, HID_USAGE_PAGE_ORDINAL, i, 0, value_caps, &caps_count, preparsed);
-            if (status == HIDP_STATUS_SUCCESS) waveform_caps_count += caps_count;
-        }
-    }
-    for (i = 0; i < waveform_caps_count; ++i) check_waveform_caps(controller, device, preparsed, collections, waveform_caps + i);
-    free(collections);
-
-    if (controller->hid.haptics_rumble_caps.UsagePage ||
-        controller->hid.haptics_buzz_caps.UsagePage)
-    {
-        caps->Flags |= XINPUT_CAPS_FFB_SUPPORTED;
-        caps->Vibration.wLeftMotorSpeed = 255;
-        caps->Vibration.wRightMotorSpeed = 255;
-    }
-
-    return TRUE;
-}
-
-static DWORD HID_set_state(struct xinput_controller *controller, XINPUT_VIBRATION *state)
-{
-    ULONG report_len = controller->hid.caps.OutputReportByteLength;
-    PHIDP_PREPARSED_DATA preparsed = controller->hid.preparsed;
-    char *report_buf = controller->hid.output_report_buf;
-    BOOL ret, update_rumble, update_buzz;
-    USHORT collection;
-    NTSTATUS status;
-    BYTE report_id;
-
-    if (!(controller->caps.Flags & XINPUT_CAPS_FFB_SUPPORTED)) return ERROR_SUCCESS;
-
-    update_rumble = (controller->vibration.wLeftMotorSpeed != state->wLeftMotorSpeed);
-    controller->vibration.wLeftMotorSpeed = state->wLeftMotorSpeed;
-    update_buzz = (controller->vibration.wRightMotorSpeed != state->wRightMotorSpeed);
-    controller->vibration.wRightMotorSpeed = state->wRightMotorSpeed;
-
-    if (!controller->enabled) return ERROR_SUCCESS;
-    if (!update_rumble && !update_buzz) return ERROR_SUCCESS;
-
-    report_id = controller->hid.haptics_report;
-    status = HidP_InitializeReportForID(HidP_Output, report_id, preparsed, report_buf, report_len);
-    if (status != HIDP_STATUS_SUCCESS) WARN("HidP_InitializeReportForID returned %#lx\n", status);
-
-    collection = controller->hid.haptics_rumble_caps.LinkCollection;
-    status = HidP_SetUsageValue(HidP_Output, HID_USAGE_PAGE_HAPTICS, collection, HID_USAGE_HAPTICS_INTENSITY,
-                                state->wLeftMotorSpeed, preparsed, report_buf, report_len);
-    if (status != HIDP_STATUS_SUCCESS) WARN("HidP_SetUsageValue INTENSITY returned %#lx\n", status);
-
-    collection = controller->hid.haptics_buzz_caps.LinkCollection;
-    status = HidP_SetUsageValue(HidP_Output, HID_USAGE_PAGE_HAPTICS, collection, HID_USAGE_HAPTICS_INTENSITY,
-                                state->wRightMotorSpeed, preparsed, report_buf, report_len);
-    if (status != HIDP_STATUS_SUCCESS) WARN("HidP_SetUsageValue INTENSITY returned %#lx\n", status);
-
-    ret = HidD_SetOutputReport(controller->device, report_buf, report_len);
-    if (!ret) WARN("HidD_SetOutputReport failed with error %lu\n", GetLastError());
-    return 0;
-
-    return ERROR_SUCCESS;
-}
-
-static void controller_destroy(struct xinput_controller *controller, BOOL already_removed);
-
-static void controller_enable(struct xinput_controller *controller)
-{
-    ULONG report_len = controller->hid.caps.InputReportByteLength;
-    char *report_buf = controller->hid.input_report_buf;
-    XINPUT_VIBRATION state = controller->vibration;
-    BOOL ret;
-
-    if (controller->enabled) return;
-    if (controller->caps.Flags & XINPUT_CAPS_FFB_SUPPORTED) HID_set_state(controller, &state);
-    controller->enabled = TRUE;
-
-    memset(&controller->hid.read_ovl, 0, sizeof(controller->hid.read_ovl));
-    controller->hid.read_ovl.hEvent = controller->hid.read_event;
-    ret = ReadFile(controller->device, report_buf, report_len, NULL, &controller->hid.read_ovl);
-    if (!ret && GetLastError() != ERROR_IO_PENDING) controller_destroy(controller, TRUE);
-    else SetEvent(update_event);
-}
-
-static void controller_disable(struct xinput_controller *controller)
-{
-    XINPUT_VIBRATION state = {0};
-
-    if (!controller->enabled) return;
-    if (controller->caps.Flags & XINPUT_CAPS_FFB_SUPPORTED) HID_set_state(controller, &state);
-    controller->enabled = FALSE;
-
-    CancelIoEx(controller->device, &controller->hid.read_ovl);
-    WaitForSingleObject(controller->hid.read_ovl.hEvent, INFINITE);
-    SetEvent(update_event);
-}
-
-static BOOL controller_init(struct xinput_controller *controller, PHIDP_PREPARSED_DATA preparsed,
-                            HIDP_CAPS *caps, HANDLE device, const WCHAR *device_path)
-{
-    HANDLE event = NULL;
-
-    controller->hid.caps = *caps;
-    if (!(controller->hid.feature_report_buf = calloc(1, controller->hid.caps.FeatureReportByteLength))) goto failed;
-    if (!controller_check_caps(controller, device, preparsed)) goto failed;
-    if (!(event = CreateEventW(NULL, TRUE, FALSE, NULL))) goto failed;
-
-    TRACE("Found gamepad %s\n", debugstr_w(device_path));
-
-    controller->hid.preparsed = preparsed;
-    controller->hid.read_event = event;
-    if (!(controller->hid.input_report_buf = calloc(1, controller->hid.caps.InputReportByteLength))) goto failed;
-    if (!(controller->hid.output_report_buf = calloc(1, controller->hid.caps.OutputReportByteLength))) goto failed;
-
-    memset(&controller->state, 0, sizeof(controller->state));
-    memset(&controller->vibration, 0, sizeof(controller->vibration));
-    lstrcpynW(controller->device_path, device_path, MAX_PATH);
-    controller->enabled = FALSE;
-
-    EnterCriticalSection(&controller->crit);
-    controller->device = device;
-    controller_enable(controller);
-    LeaveCriticalSection(&controller->crit);
     return TRUE;
-
-failed:
-    free(controller->hid.input_report_buf);
-    free(controller->hid.output_report_buf);
-    free(controller->hid.feature_report_buf);
-    memset(&controller->hid, 0, sizeof(controller->hid));
-    CloseHandle(event);
-    return FALSE;
-}
-
-static void get_registry_keys(HKEY *defkey, HKEY *appkey)
-{
-    WCHAR buffer[MAX_PATH + 26], *name = buffer, *tmp;
-    DWORD len;
-    HKEY hkey;
-
-    *appkey = 0;
-    if (RegOpenKeyW(HKEY_CURRENT_USER, L"Software\\Wine\\DirectInput\\Joysticks", defkey))
-        *defkey = 0;
-
-    if (!(len = GetModuleFileNameW(0, buffer, MAX_PATH)) || len >= MAX_PATH)
-        return;
-
-    if (!RegOpenKeyW(HKEY_CURRENT_USER, L"Software\\Wine\\AppDefaults", &hkey))
-    {
-        if ((tmp = wcsrchr(name, '/'))) name = tmp + 1;
-        if ((tmp = wcsrchr(name, '\\'))) name = tmp + 1;
-        wcscat(name, L"\\DirectInput\\Joysticks");
-        if (RegOpenKeyW(hkey, name, appkey)) *appkey = 0;
-        RegCloseKey(hkey);
-    }
-}
-
-static BOOL device_is_overridden(HANDLE device)
-{
-    WCHAR name[MAX_PATH], buffer[MAX_PATH];
-    DWORD size = sizeof(buffer);
-    BOOL disable = FALSE;
-    HKEY defkey, appkey;
-
-    if (!HidD_GetProductString(device, name, MAX_PATH)) return FALSE;
-
-    get_registry_keys(&defkey, &appkey);
-    if (!defkey && !appkey) return FALSE;
-    if ((appkey && !RegQueryValueExW(appkey, name, 0, NULL, (LPBYTE)buffer, &size)) ||
-        (defkey && !RegQueryValueExW(defkey, name, 0, NULL, (LPBYTE)buffer, &size)))
-    {
-        if ((disable = !wcscmp(buffer, L"override")))
-            TRACE("Disabling gamepad '%s' based on registry key.\n", debugstr_w(name));
-    }
-
-    if (appkey) RegCloseKey(appkey);
-    if (defkey) RegCloseKey(defkey);
-    return disable;
-}
-
-static BOOL try_add_device(const WCHAR *device_path)
-{
-    SP_DEVICE_INTERFACE_DATA iface = {sizeof(iface)};
-    PHIDP_PREPARSED_DATA preparsed;
-    HIDP_CAPS caps;
-    NTSTATUS status;
-    HANDLE device;
-    int i;
-
-    if (find_opened_device(device_path, &i)) return TRUE; /* already opened */
-    if (i == XUSER_MAX_COUNT) return FALSE; /* no more slots */
-
-    device = CreateFileW(device_path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
-                         NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, NULL);
-    if (device == INVALID_HANDLE_VALUE) return TRUE;
-
-    preparsed = NULL;
-    if (!HidD_GetPreparsedData(device, &preparsed))
-        WARN("ignoring HID device, HidD_GetPreparsedData failed with error %lu\n", GetLastError());
-    else if ((status = HidP_GetCaps(preparsed, &caps)) != HIDP_STATUS_SUCCESS)
-        WARN("ignoring HID device, HidP_GetCaps returned %#lx\n", status);
-    else if (caps.UsagePage != HID_USAGE_PAGE_GENERIC)
-        WARN("ignoring HID device, unsupported usage page %04x\n", caps.UsagePage);
-    else if (caps.Usage != HID_USAGE_GENERIC_GAMEPAD && caps.Usage != HID_USAGE_GENERIC_JOYSTICK &&
-             caps.Usage != HID_USAGE_GENERIC_MULTI_AXIS_CONTROLLER)
-        WARN("ignoring HID device, unsupported usage %04x:%04x\n", caps.UsagePage, caps.Usage);
-    else if (device_is_overridden(device))
-        WARN("ignoring HID device, overridden for dinput\n");
-    else if (!controller_init(&controllers[i], preparsed, &caps, device, device_path))
-        WARN("ignoring HID device, failed to initialize\n");
-    else
-        return TRUE;
-
-    CloseHandle(device);
-    HidD_FreePreparsedData(preparsed);
-    return TRUE;
-}
-
-static void try_remove_device(const WCHAR *device_path)
-{
-    int i;
-
-    if (find_opened_device(device_path, &i))
-        controller_destroy(&controllers[i], TRUE);
-}
-
-static void update_controller_list(void)
-{
-    char buffer[sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W) + MAX_PATH * sizeof(WCHAR)];
-    SP_DEVICE_INTERFACE_DETAIL_DATA_W *detail = (SP_DEVICE_INTERFACE_DETAIL_DATA_W *)buffer;
-    SP_DEVICE_INTERFACE_DATA iface = {sizeof(iface)};
-    HDEVINFO set;
-    DWORD idx;
-    GUID guid;
-
-    guid = GUID_DEVINTERFACE_WINEXINPUT;
-
-    set = SetupDiGetClassDevsW(&guid, NULL, NULL, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
-    detail->cbSize = sizeof(*detail);
-
-    idx = 0;
-    while (SetupDiEnumDeviceInterfaces(set, NULL, &guid, idx++, &iface))
-    {
-        if (!SetupDiGetDeviceInterfaceDetailW(set, &iface, detail, sizeof(buffer), NULL, NULL))
-            continue;
-        if (!try_add_device(detail->DevicePath))
-            break;
-    }
-
-    SetupDiDestroyDeviceInfoList(set);
-}
-
-static void controller_destroy(struct xinput_controller *controller, BOOL already_removed)
-{
-    EnterCriticalSection(&controller->crit);
-
-    if (controller->device)
-    {
-        if (!already_removed) controller_disable(controller);
-        CloseHandle(controller->device);
-        controller->device = NULL;
-
-        free(controller->hid.input_report_buf);
-        free(controller->hid.output_report_buf);
-        free(controller->hid.feature_report_buf);
-        HidD_FreePreparsedData(controller->hid.preparsed);
-        memset(&controller->hid, 0, sizeof(controller->hid));
-    }
-
-    LeaveCriticalSection(&controller->crit);
 }
 
-static LONG sign_extend(ULONG value, const HIDP_VALUE_CAPS *caps)
-{
-    UINT sign = 1 << (caps->BitSize - 1);
-    if (sign <= 1 || caps->LogicalMin >= 0) return value;
-    return value - ((value & sign) << 1);
+static void controller_destroy(void)
+{   
+    EnterCriticalSection(&controller.crit);
+    thread_running = FALSE;
+    release_gamepad_request();
+    xinput_min_index = 3;
+    
+    controller.enabled = FALSE;
+    controller.connected = FALSE;
+    
+    close_server_socket();
+    LeaveCriticalSection(&controller.crit);
 }
 
-static LONG scale_value(ULONG value, const HIDP_VALUE_CAPS *caps, LONG min, LONG max)
+static void controller_init(void)
 {
-    LONG tmp = sign_extend(value, caps);
-    if (caps->LogicalMin > caps->LogicalMax) return 0;
-    if (caps->LogicalMin > tmp || caps->LogicalMax < tmp) return 0;
-    return min + MulDiv(tmp - caps->LogicalMin, max - min, caps->LogicalMax - caps->LogicalMin);
+    memset(&controller.state, 0, sizeof(controller.state));
+    controller_check_caps();
+    controller.connected = TRUE;
+    controller.enabled = TRUE;
 }
 
-static void read_controller_state(struct xinput_controller *controller)
+static void controller_update_state(char *buffer)
 {
-    ULONG read_len, report_len = controller->hid.caps.InputReportByteLength;
-    char *report_buf = controller->hid.input_report_buf;
-    XINPUT_STATE state;
-    NTSTATUS status;
-    USAGE buttons[11];
-    ULONG i, button_length, value;
-    BOOL ret;
-
-    if (!GetOverlappedResult(controller->device, &controller->hid.read_ovl, &read_len, TRUE))
+    int i, gamepad_id;
+    char dpad;
+    short buttons, thumb_lx, thumb_ly, thumb_rx, thumb_ry;
+    XINPUT_STATE *state = &controller.state;
+    
+    EnterCriticalSection(&controller.crit);
+    
+    gamepad_id = *(int*)(buffer + 2);
+    if (buffer[1] != 1 || gamepad_id != controller.id) 
     {
-        if (GetLastError() == ERROR_OPERATION_ABORTED) return;
-        if (GetLastError() == ERROR_ACCESS_DENIED || GetLastError() == ERROR_INVALID_HANDLE) controller_destroy(controller, TRUE);
-        else ERR("Failed to read input report, GetOverlappedResult failed with error %lu\n", GetLastError());
+        controller.connected = FALSE;
+        memset(&controller.state, 0, sizeof(controller.state));
+        LeaveCriticalSection(&controller.crit);
         return;
     }
-
-    button_length = ARRAY_SIZE(buttons);
-    status = HidP_GetUsages(HidP_Input, HID_USAGE_PAGE_BUTTON, 0, buttons, &button_length, controller->hid.preparsed, report_buf, report_len);
-    if (status != HIDP_STATUS_SUCCESS) WARN("HidP_GetUsages HID_USAGE_PAGE_BUTTON returned %#lx\n", status);
-
-    state.Gamepad.wButtons = 0;
-    for (i = 0; i < button_length; i++)
-    {
-        switch (buttons[i])
-        {
-        case 1: state.Gamepad.wButtons |= XINPUT_GAMEPAD_A; break;
-        case 2: state.Gamepad.wButtons |= XINPUT_GAMEPAD_B; break;
-        case 3: state.Gamepad.wButtons |= XINPUT_GAMEPAD_X; break;
-        case 4: state.Gamepad.wButtons |= XINPUT_GAMEPAD_Y; break;
-        case 5: state.Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_SHOULDER; break;
-        case 6: state.Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_SHOULDER; break;
-        case 7: state.Gamepad.wButtons |= XINPUT_GAMEPAD_BACK; break;
-        case 8: state.Gamepad.wButtons |= XINPUT_GAMEPAD_START; break;
-        case 9: state.Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_THUMB; break;
-        case 10: state.Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_THUMB; break;
-        case 11: state.Gamepad.wButtons |= XINPUT_GAMEPAD_GUIDE; break;
+    
+    buttons = *(short*)(buffer + 6);    
+    dpad = buffer[8];
+    
+    thumb_lx = *(short*)(buffer + 9);
+    thumb_ly = *(short*)(buffer + 11);
+    thumb_rx = *(short*)(buffer + 13);
+    thumb_ry = *(short*)(buffer + 15);
+
+    state->Gamepad.wButtons = 0;
+    for (i = 0; i < 10; i++)
+    {    
+        if ((buttons & (1<<i))) {
+            switch (i)
+            {
+            case IDX_BUTTON_A: state->Gamepad.wButtons |= XINPUT_GAMEPAD_A; break;
+            case IDX_BUTTON_B: state->Gamepad.wButtons |= XINPUT_GAMEPAD_B; break;
+            case IDX_BUTTON_X: state->Gamepad.wButtons |= XINPUT_GAMEPAD_X; break;
+            case IDX_BUTTON_Y: state->Gamepad.wButtons |= XINPUT_GAMEPAD_Y; break;
+            case IDX_BUTTON_L1: state->Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_SHOULDER; break;
+            case IDX_BUTTON_R1: state->Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_SHOULDER; break;
+            case IDX_BUTTON_SELECT: state->Gamepad.wButtons |= XINPUT_GAMEPAD_BACK; break;
+            case IDX_BUTTON_START: state->Gamepad.wButtons |= XINPUT_GAMEPAD_START; break;
+            case IDX_BUTTON_L3: state->Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_THUMB; break;
+            case IDX_BUTTON_R3: state->Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_THUMB; break;
+            }
         }
     }
-
-    status = HidP_GetUsageValue(HidP_Input, HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_HATSWITCH, &value, controller->hid.preparsed, report_buf, report_len);
-    if (status != HIDP_STATUS_SUCCESS) WARN("HidP_GetUsageValue HID_USAGE_PAGE_GENERIC / HID_USAGE_GENERIC_HATSWITCH returned %#lx\n", status);
-    else switch (value)
-    {
-    /* 8 1 2
-     * 7 0 3
-     * 6 5 4 */
-    case 0: break;
-    case 1: state.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_UP; break;
-    case 2: state.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_UP | XINPUT_GAMEPAD_DPAD_RIGHT; break;
-    case 3: state.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_RIGHT; break;
-    case 4: state.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_RIGHT | XINPUT_GAMEPAD_DPAD_DOWN; break;
-    case 5: state.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_DOWN; break;
-    case 6: state.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_DOWN | XINPUT_GAMEPAD_DPAD_LEFT; break;
-    case 7: state.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_LEFT; break;
-    case 8: state.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_LEFT | XINPUT_GAMEPAD_DPAD_UP; break;
-    }
-
-    status = HidP_GetUsageValue(HidP_Input, HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_X, &value, controller->hid.preparsed, report_buf, report_len);
-    if (status != HIDP_STATUS_SUCCESS) WARN("HidP_GetUsageValue HID_USAGE_PAGE_GENERIC / HID_USAGE_GENERIC_X returned %#lx\n", status);
-    else state.Gamepad.sThumbLX = scale_value(value, &controller->hid.lx_caps, -32768, 32767);
-
-    status = HidP_GetUsageValue(HidP_Input, HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_Y, &value, controller->hid.preparsed, report_buf, report_len);
-    if (status != HIDP_STATUS_SUCCESS) WARN("HidP_GetUsageValue HID_USAGE_PAGE_GENERIC / HID_USAGE_GENERIC_Y returned %#lx\n", status);
-    else state.Gamepad.sThumbLY = -scale_value(value, &controller->hid.ly_caps, -32768, 32767) - 1;
-
-    status = HidP_GetUsageValue(HidP_Input, HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_RX, &value, controller->hid.preparsed, report_buf, report_len);
-    if (status != HIDP_STATUS_SUCCESS) WARN("HidP_GetUsageValue HID_USAGE_PAGE_GENERIC / HID_USAGE_GENERIC_RX returned %#lx\n", status);
-    else state.Gamepad.sThumbRX = scale_value(value, &controller->hid.rx_caps, -32768, 32767);
-
-    status = HidP_GetUsageValue(HidP_Input, HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_RY, &value, controller->hid.preparsed, report_buf, report_len);
-    if (status != HIDP_STATUS_SUCCESS) WARN("HidP_GetUsageValue HID_USAGE_PAGE_GENERIC / HID_USAGE_GENERIC_RY returned %#lx\n", status);
-    else state.Gamepad.sThumbRY = -scale_value(value, &controller->hid.ry_caps, -32768, 32767) - 1;
-
-    status = HidP_GetUsageValue(HidP_Input, HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_RZ, &value, controller->hid.preparsed, report_buf, report_len);
-    if (status != HIDP_STATUS_SUCCESS) WARN("HidP_GetUsageValue HID_USAGE_PAGE_GENERIC / HID_USAGE_GENERIC_RZ returned %#lx\n", status);
-    else state.Gamepad.bRightTrigger = scale_value(value, &controller->hid.rt_caps, 0, 255);
-
-    status = HidP_GetUsageValue(HidP_Input, HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_Z, &value, controller->hid.preparsed, report_buf, report_len);
-    if (status != HIDP_STATUS_SUCCESS) WARN("HidP_GetUsageValue HID_USAGE_PAGE_GENERIC / HID_USAGE_GENERIC_Z returned %#lx\n", status);
-    else state.Gamepad.bLeftTrigger = scale_value(value, &controller->hid.lt_caps, 0, 255);
-
-    EnterCriticalSection(&controller->crit);
-    if (controller->enabled)
-    {
-        state.dwPacketNumber = controller->state.dwPacketNumber + 1;
-        controller->state = state;
-        memset(&controller->hid.read_ovl, 0, sizeof(controller->hid.read_ovl));
-        controller->hid.read_ovl.hEvent = controller->hid.read_event;
-        ret = ReadFile(controller->device, report_buf, report_len, NULL, &controller->hid.read_ovl);
-        if (!ret && GetLastError() != ERROR_IO_PENDING) controller_destroy(controller, TRUE);
-    }
-    LeaveCriticalSection(&controller->crit);
-}
-
-static LRESULT CALLBACK xinput_devnotify_wndproc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
-{
-    if (msg == WM_DEVICECHANGE)
-    {
-        DEV_BROADCAST_DEVICEINTERFACE_W *iface = (DEV_BROADCAST_DEVICEINTERFACE_W *)lparam;
-        if (wparam == DBT_DEVICEARRIVAL) try_add_device(iface->dbcc_name);
-        if (wparam == DBT_DEVICEREMOVECOMPLETE) try_remove_device(iface->dbcc_name);
-    }
-
-    return DefWindowProcW(hwnd, msg, wparam, lparam);
-}
-
-static DWORD WINAPI hid_update_thread_proc(void *param)
-{
-    struct xinput_controller *devices[XUSER_MAX_COUNT + 1];
-    HANDLE events[XUSER_MAX_COUNT + 1];
-    DWORD i, count = 1, ret = WAIT_TIMEOUT;
-    DEV_BROADCAST_DEVICEINTERFACE_W filter =
-    {
-        .dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE_W),
-        .dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE,
-        .dbcc_classguid = GUID_DEVINTERFACE_WINEXINPUT,
-    };
-    WNDCLASSEXW cls =
-    {
-        .cbSize = sizeof(WNDCLASSEXW),
-        .hInstance = xinput_instance,
-        .lpszClassName = L"__wine_xinput_devnotify",
-        .lpfnWndProc = xinput_devnotify_wndproc,
-    };
-    HDEVNOTIFY notif;
-    HWND hwnd;
-    MSG msg;
-
-    SetThreadDescription(GetCurrentThread(), L"wine_xinput_hid_update");
-
-    RegisterClassExW(&cls);
-    hwnd = CreateWindowExW(0, cls.lpszClassName, NULL, 0, 0, 0, 0, 0,
-                           HWND_MESSAGE, NULL, NULL, NULL);
-    notif = RegisterDeviceNotificationW(hwnd, &filter, DEVICE_NOTIFY_WINDOW_HANDLE);
-
-    update_controller_list();
-    SetEvent(start_event);
-
-    do
-    {
-        if (ret == count) while (PeekMessageW(&msg, hwnd, 0, 0, PM_REMOVE)) DispatchMessageW(&msg);
-        if (ret == WAIT_TIMEOUT) update_controller_list();
-        if (ret < count - 1) read_controller_state(devices[ret]);
-
-        count = 0;
-        for (i = 0; i < XUSER_MAX_COUNT; ++i)
+    
+    state->Gamepad.bLeftTrigger = (buttons & (1<<10)) ? 255 : 0;
+    state->Gamepad.bRightTrigger = (buttons & (1<<11)) ? 255 : 0;
+
+    switch (dpad)
+    {
+    case 0: state->Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_UP; break;
+    case 1: state->Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_UP | XINPUT_GAMEPAD_DPAD_RIGHT; break;
+    case 2: state->Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_RIGHT; break;
+    case 3: state->Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_RIGHT | XINPUT_GAMEPAD_DPAD_DOWN; break;
+    case 4: state->Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_DOWN; break;
+    case 5: state->Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_DOWN | XINPUT_GAMEPAD_DPAD_LEFT; break;
+    case 6: state->Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_LEFT; break;
+    case 7: state->Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_LEFT | XINPUT_GAMEPAD_DPAD_UP; break;
+    }
+
+    state->Gamepad.sThumbLX = thumb_lx;
+    state->Gamepad.sThumbLY = -thumb_ly;
+    state->Gamepad.sThumbRX = thumb_rx;
+    state->Gamepad.sThumbRY = -thumb_ry;
+    
+    state->dwPacketNumber++;
+    LeaveCriticalSection(&controller.crit);
+}
+
+static DWORD WINAPI controller_read_thread_proc(void *param) {
+    int res;
+    char buffer[BUFFER_SIZE];
+    BOOL started = FALSE;
+    DWORD curr_time, last_time;
+    
+    SetThreadDescription(GetCurrentThread(), L"wine_xinput_controller_read");
+    if (server_sock == INVALID_SOCKET && !create_server_socket()) 
+    {
+        SetEvent(start_event);
+        return 0;
+    }
+    
+    get_gamepad_request();
+    
+    last_time = GetCurrentTime();
+    while (thread_running)
+    {
+        res = recvfrom(server_sock, buffer, BUFFER_SIZE, 0, NULL, 0);
+        if (res <= 0)
+        {
+            if (WSAGetLastError() != WSAEWOULDBLOCK) break;
+            
+            curr_time = GetCurrentTime();
+            if ((curr_time - last_time) >= 2000) {
+                get_gamepad_request();
+                last_time = curr_time;
+            }
+            
+            Sleep(16);
+            continue;
+        }
+        
+        if (buffer[0] == REQUEST_CODE_GET_GAMEPAD) 
         {
-            if (!controllers[i].device) continue;
-            EnterCriticalSection(&controllers[i].crit);
-            if (controllers[i].enabled)
+            int gamepad_id;
+            gamepad_id = *(int*)(buffer + 1);
+            
+            EnterCriticalSection(&controller.crit);
+            if (gamepad_id > 0) 
+            {
+                controller.id = gamepad_id;
+                if (!controller.connected) controller_init();
+            }
+            else if (gamepad_id == 0) 
             {
-                devices[count] = controllers + i;
-                events[count] = controllers[i].hid.read_event;
-                count++;
+                controller.id = 0;
+                controller.connected = FALSE;       
             }
-            LeaveCriticalSection(&controllers[i].crit);
+            LeaveCriticalSection(&controller.crit);
+            
+            if (!started) 
+            {
+                started = TRUE;
+                SetEvent(start_event);    
+            }
+        }
+        else if (buffer[0] == REQUEST_CODE_GET_GAMEPAD_STATE && controller.connected)
+        {
+            controller_update_state(buffer);
         }
-        events[count++] = update_event;
     }
-    while ((ret = MsgWaitForMultipleObjectsEx(count, events, 2000, QS_ALLINPUT, MWMO_ALERTABLE)) <= count ||
-            ret == WAIT_TIMEOUT);
-
-    ERR("wait failed in the update thread, ret %lu, error %lu\n", ret, GetLastError());
-
-    UnregisterDeviceNotification(notif);
-    DestroyWindow(hwnd);
-    UnregisterClassW(cls.lpszClassName, xinput_instance);
-
-    FreeLibraryAndExitThread(xinput_instance, ret);
+    
+    return 0;
 }
 
-static BOOL WINAPI start_update_thread_once( INIT_ONCE *once, void *param, void **context )
+static BOOL WINAPI start_read_thread_once(INIT_ONCE *once, void *param, void **context)
 {
     HANDLE thread;
-    HMODULE module;
-
-    if (!GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, (void*)hid_update_thread_proc, &module))
-        WARN("Failed to increase module's reference count, error: %lu\n", GetLastError());
+    
+    thread_running = TRUE;
 
     start_event = CreateEventA(NULL, FALSE, FALSE, NULL);
-    if (!start_event) ERR("failed to create start event, error %lu\n", GetLastError());
-
-    update_event = CreateEventA(NULL, FALSE, FALSE, NULL);
-    if (!update_event) ERR("failed to create update event, error %lu\n", GetLastError());
-
-    thread = CreateThread(NULL, 0, hid_update_thread_proc, NULL, 0, NULL);
-    if (!thread) ERR("failed to create update thread, error %lu\n", GetLastError());
+    if (!start_event) ERR("failed to create start event, error %lu\n", GetLastError());   
+    
+    thread = CreateThread(NULL, 0, controller_read_thread_proc, NULL, 0, NULL);
+    if (!thread) ERR("failed to create read thread, error %lu\n", GetLastError());
     CloseHandle(thread);
-
-    WaitForSingleObject(start_event, INFINITE);
+    
+    WaitForSingleObject(start_event, 2000);
+    CloseHandle(start_event);
+    
     return TRUE;
 }
 
-static void start_update_thread(void)
+static void start_read_thread(void)
 {
     static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
-    InitOnceExecuteOnce(&init_once, start_update_thread_once, NULL, NULL);
+    InitOnceExecuteOnce(&init_once, start_read_thread_once, NULL, NULL);
 }
 
-static BOOL controller_lock(struct xinput_controller *controller)
+static BOOL controller_is_connected(DWORD index) 
 {
-    if (!controller->device) return FALSE;
-
-    EnterCriticalSection(&controller->crit);
-
-    if (!controller->device)
-    {
-        LeaveCriticalSection(&controller->crit);
-        return FALSE;
-    }
-
-    return TRUE;
-}
-
-static void controller_unlock(struct xinput_controller *controller)
-{
-    LeaveCriticalSection(&controller->crit);
+    BOOL connected;
+    EnterCriticalSection(&controller.crit);
+    connected = index == 0 && controller.connected;
+    LeaveCriticalSection(&controller.crit);
+    return connected;
 }
 
 BOOL WINAPI DllMain(HINSTANCE inst, DWORD reason, LPVOID reserved)
@@ -788,50 +394,40 @@ BOOL WINAPI DllMain(HINSTANCE inst, DWORD reason, LPVOID reserved)
     switch (reason)
     {
     case DLL_PROCESS_ATTACH:
-        xinput_instance = inst;
         DisableThreadLibraryCalls(inst);
         break;
+    case DLL_PROCESS_DETACH:
+        if (reserved) break;
+        controller_destroy();
+        break;
     }
     return TRUE;
 }
 
 void WINAPI DECLSPEC_HOTPATCH XInputEnable(BOOL enable)
 {
-    int index;
-
     TRACE("enable %d.\n", enable);
 
     /* Setting to false will stop messages from XInputSetState being sent
     to the controllers. Setting to true will send the last vibration
     value (sent to XInputSetState) to the controller and allow messages to
     be sent */
-    start_update_thread();
+    start_read_thread();
 
-    for (index = 0; index < XUSER_MAX_COUNT; index++)
-    {
-        if (!controller_lock(&controllers[index])) continue;
-        if (enable) controller_enable(&controllers[index]);
-        else controller_disable(&controllers[index]);
-        controller_unlock(&controllers[index]);
-    }
+    if (!controller.connected) return;
+    controller.enabled = enable;    
 }
 
 DWORD WINAPI DECLSPEC_HOTPATCH XInputSetState(DWORD index, XINPUT_VIBRATION *vibration)
 {
-    DWORD ret;
-
     TRACE("index %lu, vibration %p.\n", index, vibration);
 
-    start_update_thread();
+    start_read_thread();
 
     if (index >= XUSER_MAX_COUNT) return ERROR_BAD_ARGUMENTS;
-    if (!controller_lock(&controllers[index])) return ERROR_DEVICE_NOT_CONNECTED;
+    if (!controller_is_connected(index)) return ERROR_DEVICE_NOT_CONNECTED;
 
-    ret = HID_set_state(&controllers[index], vibration);
-
-    controller_unlock(&controllers[index]);
-
-    return ret;
+    return ERROR_SUCCESS;
 }
 
 /* Some versions of SteamOverlayRenderer hot-patch XInputGetStateEx() and call
@@ -840,14 +436,16 @@ static DWORD xinput_get_state(DWORD index, XINPUT_STATE *state)
 {
     if (!state) return ERROR_BAD_ARGUMENTS;
 
-    start_update_thread();
+    start_read_thread();
 
     if (index >= XUSER_MAX_COUNT) return ERROR_BAD_ARGUMENTS;
-    if (!controller_lock(&controllers[index])) return ERROR_DEVICE_NOT_CONNECTED;
-
-    *state = controllers[index].state;
-    controller_unlock(&controllers[index]);
-
+    if (index < xinput_min_index) xinput_min_index = index;
+    if (index == xinput_min_index) index = 0;
+    if (!controller_is_connected(index)) return ERROR_DEVICE_NOT_CONNECTED;
+    
+    EnterCriticalSection(&controller.crit);
+    *state = controller.state;
+    LeaveCriticalSection(&controller.crit);
     return ERROR_SUCCESS;
 }
 
@@ -906,8 +504,8 @@ static WORD js_vk_offs(const int x, const int y)
     }
 }
 
-static DWORD check_joystick_keystroke(const DWORD index, XINPUT_KEYSTROKE *keystroke, const SHORT *cur_x,
-                                      const SHORT *cur_y, SHORT *last_x, SHORT *last_y, const WORD base_vk)
+static DWORD check_joystick_keystroke(XINPUT_KEYSTROKE *keystroke, const SHORT *cur_x, const SHORT *cur_y, 
+                                      SHORT *last_x, SHORT *last_y, const WORD base_vk)
 {
     int cur_vk = 0, cur_x_st, cur_y_st;
     int last_vk = 0, last_x_st, last_y_st;
@@ -932,7 +530,7 @@ static DWORD check_joystick_keystroke(const DWORD index, XINPUT_KEYSTROKE *keyst
             keystroke->VirtualKey = last_vk;
             keystroke->Unicode = 0; /* unused */
             keystroke->Flags = XINPUT_KEYSTROKE_KEYUP;
-            keystroke->UserIndex = index;
+            keystroke->UserIndex = 0;
             keystroke->HidCode = 0;
 
             *last_x = 0;
@@ -945,7 +543,7 @@ static DWORD check_joystick_keystroke(const DWORD index, XINPUT_KEYSTROKE *keyst
         keystroke->VirtualKey = cur_vk;
         keystroke->Unicode = 0; /* unused */
         keystroke->Flags = XINPUT_KEYSTROKE_KEYDOWN;
-        keystroke->UserIndex = index;
+        keystroke->UserIndex = 0;
         keystroke->HidCode = 0;
 
         *last_x = *cur_x;
@@ -965,9 +563,8 @@ static BOOL trigger_is_on(const BYTE value)
     return value > 30;
 }
 
-static DWORD check_for_keystroke(const DWORD index, XINPUT_KEYSTROKE *keystroke)
+static DWORD check_for_keystroke(XINPUT_KEYSTROKE *keystroke)
 {
-    struct xinput_controller *controller = &controllers[index];
     const XINPUT_GAMEPAD *cur;
     DWORD ret = ERROR_EMPTY;
     int i;
@@ -994,28 +591,26 @@ static DWORD check_for_keystroke(const DWORD index, XINPUT_KEYSTROKE *keystroke)
         /* note: guide button does not send an event */
     };
 
-    if (!controller_lock(controller)) return ERROR_DEVICE_NOT_CONNECTED;
-
-    cur = &controller->state.Gamepad;
+    cur = &controller.state.Gamepad;
 
     /*** buttons ***/
     for (i = 0; i < ARRAY_SIZE(buttons); ++i)
     {
-        if ((cur->wButtons & buttons[i].mask) ^ (controller->last_keystroke.wButtons & buttons[i].mask))
+        if ((cur->wButtons & buttons[i].mask) ^ (controller.last_keystroke.wButtons & buttons[i].mask))
         {
             keystroke->VirtualKey = buttons[i].vk;
             keystroke->Unicode = 0; /* unused */
             if (cur->wButtons & buttons[i].mask)
             {
                 keystroke->Flags = XINPUT_KEYSTROKE_KEYDOWN;
-                controller->last_keystroke.wButtons |= buttons[i].mask;
+                controller.last_keystroke.wButtons |= buttons[i].mask;
             }
             else
             {
                 keystroke->Flags = XINPUT_KEYSTROKE_KEYUP;
-                controller->last_keystroke.wButtons &= ~buttons[i].mask;
+                controller.last_keystroke.wButtons &= ~buttons[i].mask;
             }
-            keystroke->UserIndex = index;
+            keystroke->UserIndex = 0;
             keystroke->HidCode = 0;
             ret = ERROR_SUCCESS;
             goto done;
@@ -1023,65 +618,56 @@ static DWORD check_for_keystroke(const DWORD index, XINPUT_KEYSTROKE *keystroke)
     }
 
     /*** triggers ***/
-    if (trigger_is_on(cur->bLeftTrigger) ^ trigger_is_on(controller->last_keystroke.bLeftTrigger))
+    if (trigger_is_on(cur->bLeftTrigger) ^ trigger_is_on(controller.last_keystroke.bLeftTrigger))
     {
         keystroke->VirtualKey = VK_PAD_LTRIGGER;
         keystroke->Unicode = 0; /* unused */
         keystroke->Flags = trigger_is_on(cur->bLeftTrigger) ? XINPUT_KEYSTROKE_KEYDOWN : XINPUT_KEYSTROKE_KEYUP;
-        keystroke->UserIndex = index;
+        keystroke->UserIndex = 0;
         keystroke->HidCode = 0;
-        controller->last_keystroke.bLeftTrigger = cur->bLeftTrigger;
+        controller.last_keystroke.bLeftTrigger = cur->bLeftTrigger;
         ret = ERROR_SUCCESS;
         goto done;
     }
 
-    if (trigger_is_on(cur->bRightTrigger) ^ trigger_is_on(controller->last_keystroke.bRightTrigger))
+    if (trigger_is_on(cur->bRightTrigger) ^ trigger_is_on(controller.last_keystroke.bRightTrigger))
     {
         keystroke->VirtualKey = VK_PAD_RTRIGGER;
         keystroke->Unicode = 0; /* unused */
         keystroke->Flags = trigger_is_on(cur->bRightTrigger) ? XINPUT_KEYSTROKE_KEYDOWN : XINPUT_KEYSTROKE_KEYUP;
-        keystroke->UserIndex = index;
+        keystroke->UserIndex = 0;
         keystroke->HidCode = 0;
-        controller->last_keystroke.bRightTrigger = cur->bRightTrigger;
+        controller.last_keystroke.bRightTrigger = cur->bRightTrigger;
         ret = ERROR_SUCCESS;
         goto done;
     }
 
     /*** joysticks ***/
-    ret = check_joystick_keystroke(index, keystroke, &cur->sThumbLX, &cur->sThumbLY,
-            &controller->last_keystroke.sThumbLX,
-            &controller->last_keystroke.sThumbLY, VK_PAD_LTHUMB_UP);
+    ret = check_joystick_keystroke(keystroke, &cur->sThumbLX, &cur->sThumbLY,
+            &controller.last_keystroke.sThumbLX,
+            &controller.last_keystroke.sThumbLY, VK_PAD_LTHUMB_UP);
     if (ret == ERROR_SUCCESS)
         goto done;
 
-    ret = check_joystick_keystroke(index, keystroke, &cur->sThumbRX, &cur->sThumbRY,
-            &controller->last_keystroke.sThumbRX,
-            &controller->last_keystroke.sThumbRY, VK_PAD_RTHUMB_UP);
+    ret = check_joystick_keystroke(keystroke, &cur->sThumbRX, &cur->sThumbRY,
+            &controller.last_keystroke.sThumbRX,
+            &controller.last_keystroke.sThumbRY, VK_PAD_RTHUMB_UP);
     if (ret == ERROR_SUCCESS)
         goto done;
 
 done:
-    controller_unlock(controller);
 
     return ret;
 }
 
 DWORD WINAPI DECLSPEC_HOTPATCH XInputGetKeystroke(DWORD index, DWORD reserved, PXINPUT_KEYSTROKE keystroke)
-{
+{    
     TRACE("index %lu, reserved %lu, keystroke %p.\n", index, reserved, keystroke);
 
     if (index >= XUSER_MAX_COUNT && index != XUSER_INDEX_ANY) return ERROR_BAD_ARGUMENTS;
-
-    if (index == XUSER_INDEX_ANY)
-    {
-        int i;
-        for (i = 0; i < XUSER_MAX_COUNT; ++i)
-            if (check_for_keystroke(i, keystroke) == ERROR_SUCCESS)
-                return ERROR_SUCCESS;
-        return ERROR_EMPTY;
-    }
-
-    return check_for_keystroke(index, keystroke);
+    if (!controller_is_connected(index != XUSER_INDEX_ANY ? index : 0)) return ERROR_DEVICE_NOT_CONNECTED;
+  
+    return check_for_keystroke(keystroke);
 }
 
 DWORD WINAPI DECLSPEC_HOTPATCH XInputGetCapabilities(DWORD index, DWORD flags, XINPUT_CAPABILITIES *capabilities)
@@ -1092,59 +678,45 @@ DWORD WINAPI DECLSPEC_HOTPATCH XInputGetCapabilities(DWORD index, DWORD flags, X
     ret = XInputGetCapabilitiesEx(1, index, flags, &caps_ex);
 
     if (!ret) *capabilities = caps_ex.Capabilities;
-
     return ret;
 }
 
 DWORD WINAPI DECLSPEC_HOTPATCH XInputGetDSoundAudioDeviceGuids(DWORD index, GUID *render_guid, GUID *capture_guid)
 {
-    FIXME("index %lu, render_guid %s, capture_guid %s stub!\n", index, debugstr_guid(render_guid),
-          debugstr_guid(capture_guid));
-
     if (index >= XUSER_MAX_COUNT) return ERROR_BAD_ARGUMENTS;
-    if (!controllers[index].device) return ERROR_DEVICE_NOT_CONNECTED;
+    if (!controller_is_connected(index)) return ERROR_DEVICE_NOT_CONNECTED;
 
     return ERROR_NOT_SUPPORTED;
 }
 
 DWORD WINAPI DECLSPEC_HOTPATCH XInputGetBatteryInformation(DWORD index, BYTE type, XINPUT_BATTERY_INFORMATION* battery)
 {
-    static int once;
-
-    if (!once++) FIXME("index %lu, type %u, battery %p.\n", index, type, battery);
-
     if (index >= XUSER_MAX_COUNT) return ERROR_BAD_ARGUMENTS;
-    if (!controllers[index].device) return ERROR_DEVICE_NOT_CONNECTED;
+    if (!controller_is_connected(index)) return ERROR_DEVICE_NOT_CONNECTED;
 
     return ERROR_NOT_SUPPORTED;
 }
 
 DWORD WINAPI DECLSPEC_HOTPATCH XInputGetCapabilitiesEx(DWORD unk, DWORD index, DWORD flags, XINPUT_CAPABILITIES_EX *caps)
 {
-    HIDD_ATTRIBUTES attr;
-    DWORD ret = ERROR_SUCCESS;
-
     TRACE("unk %lu, index %lu, flags %#lx, capabilities %p.\n", unk, index, flags, caps);
 
-    start_update_thread();
+    start_read_thread();
 
     if (index >= XUSER_MAX_COUNT) return ERROR_BAD_ARGUMENTS;
+    if (!controller_is_connected(index)) return ERROR_DEVICE_NOT_CONNECTED;
+    
+    EnterCriticalSection(&controller.crit);
 
-    if (!controller_lock(&controllers[index])) return ERROR_DEVICE_NOT_CONNECTED;
-
-    if (flags & XINPUT_FLAG_GAMEPAD && controllers[index].caps.SubType != XINPUT_DEVSUBTYPE_GAMEPAD)
-        ret = ERROR_DEVICE_NOT_CONNECTED;
-    else if (!HidD_GetAttributes(controllers[index].device, &attr))
-        ret = ERROR_DEVICE_NOT_CONNECTED;
+    if (flags & XINPUT_FLAG_GAMEPAD && controller.caps.SubType != XINPUT_DEVSUBTYPE_GAMEPAD) 
+        return ERROR_DEVICE_NOT_CONNECTED;
     else
     {
-        caps->Capabilities = controllers[index].caps;
-        caps->VendorId = attr.VendorID;
-        caps->ProductId = attr.ProductID;
-        caps->VersionNumber = attr.VersionNumber;
+        caps->Capabilities = controller.caps;
+        caps->VendorId = 0x045E; // Wireless Xbox 360 Controller
+        caps->ProductId = 0x02A1;
     }
 
-    controller_unlock(&controllers[index]);
-
-    return ret;
-}
+    LeaveCriticalSection(&controller.crit);
+    return ERROR_SUCCESS;
+}
\ No newline at end of file
diff --git a/dlls/xinput1_4/Makefile.in b/dlls/xinput1_4/Makefile.in
index 69d6b9c..a834edf 100755
--- a/dlls/xinput1_4/Makefile.in
+++ b/dlls/xinput1_4/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = xinput1_4.dll
-IMPORTS   = hid setupapi advapi32 user32
+IMPORTS   = hid setupapi advapi32 user32 ws2_32
 PARENTSRC = ../xinput1_3
 
 SOURCES = \
diff --git a/dlls/xinput9_1_0/Makefile.in b/dlls/xinput9_1_0/Makefile.in
index d5f2adf..915171b 100755
--- a/dlls/xinput9_1_0/Makefile.in
+++ b/dlls/xinput9_1_0/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = xinput9_1_0.dll
-IMPORTS   = hid setupapi advapi32 user32
+IMPORTS   = hid setupapi advapi32 user32 ws2_32
 PARENTSRC = ../xinput1_3
 
 SOURCES = \
diff --git a/dlls/xinputuap/Makefile.in b/dlls/xinputuap/Makefile.in
index 290f083..28d5401 100755
--- a/dlls/xinputuap/Makefile.in
+++ b/dlls/xinputuap/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = xinputuap.dll
-IMPORTS   = hid setupapi advapi32 user32
+IMPORTS   = hid setupapi advapi32 user32 ws2_32
 PARENTSRC = ../xinput1_3
 
 SOURCES = \
 
